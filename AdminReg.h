// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.1.0.
// **********************************************************************

#ifndef __ADMINREG_H_
#define __ADMINREG_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
using namespace std;
#include "NodeDescriptor.h"
#include "servant/ServantProxy.h"
#include "servant/Servant.h"
#include "promise/promise.h"


namespace tars
{
    enum tarsErrCode
    {
        EM_TARS_NODE_NOT_REGISTRY_ERR = 1001,
        EM_TARS_CALL_NODE_TIMEOUT_ERR = 1002,
        EM_TARS_LOAD_SERVICE_DESC_ERR = 1003,
        EM_TARS_SERVICE_STATE_ERR = 1004,
        EM_TARS_REQ_ALREADY_ERR = 1005,
        EM_TARS_INVALID_IP_ERR = 1006,
        EM_TARS_PARAMETER_ERR = 1007,
        EM_TARS_OTHER_ERR = 1008,
        EM_TARS_GET_PATCH_FILE_ERR = 1009,
        EM_TARS_PREPARE_ERR = 1010,
        EM_TARS_UNKNOWN_ERR = -1,
        EM_TARS_SUCCESS = 0,
    };
    inline string etos(const tarsErrCode & e)
    {
        switch(e)
        {
            case EM_TARS_NODE_NOT_REGISTRY_ERR: return "EM_TARS_NODE_NOT_REGISTRY_ERR";
            case EM_TARS_CALL_NODE_TIMEOUT_ERR: return "EM_TARS_CALL_NODE_TIMEOUT_ERR";
            case EM_TARS_LOAD_SERVICE_DESC_ERR: return "EM_TARS_LOAD_SERVICE_DESC_ERR";
            case EM_TARS_SERVICE_STATE_ERR: return "EM_TARS_SERVICE_STATE_ERR";
            case EM_TARS_REQ_ALREADY_ERR: return "EM_TARS_REQ_ALREADY_ERR";
            case EM_TARS_INVALID_IP_ERR: return "EM_TARS_INVALID_IP_ERR";
            case EM_TARS_PARAMETER_ERR: return "EM_TARS_PARAMETER_ERR";
            case EM_TARS_OTHER_ERR: return "EM_TARS_OTHER_ERR";
            case EM_TARS_GET_PATCH_FILE_ERR: return "EM_TARS_GET_PATCH_FILE_ERR";
            case EM_TARS_PREPARE_ERR: return "EM_TARS_PREPARE_ERR";
            case EM_TARS_UNKNOWN_ERR: return "EM_TARS_UNKNOWN_ERR";
            case EM_TARS_SUCCESS: return "EM_TARS_SUCCESS";
            default: return "";
        }
    }
    inline int stoe(const string & s, tarsErrCode & e)
    {
        if(s == "EM_TARS_NODE_NOT_REGISTRY_ERR")  { e=EM_TARS_NODE_NOT_REGISTRY_ERR; return 0;}
        if(s == "EM_TARS_CALL_NODE_TIMEOUT_ERR")  { e=EM_TARS_CALL_NODE_TIMEOUT_ERR; return 0;}
        if(s == "EM_TARS_LOAD_SERVICE_DESC_ERR")  { e=EM_TARS_LOAD_SERVICE_DESC_ERR; return 0;}
        if(s == "EM_TARS_SERVICE_STATE_ERR")  { e=EM_TARS_SERVICE_STATE_ERR; return 0;}
        if(s == "EM_TARS_REQ_ALREADY_ERR")  { e=EM_TARS_REQ_ALREADY_ERR; return 0;}
        if(s == "EM_TARS_INVALID_IP_ERR")  { e=EM_TARS_INVALID_IP_ERR; return 0;}
        if(s == "EM_TARS_PARAMETER_ERR")  { e=EM_TARS_PARAMETER_ERR; return 0;}
        if(s == "EM_TARS_OTHER_ERR")  { e=EM_TARS_OTHER_ERR; return 0;}
        if(s == "EM_TARS_GET_PATCH_FILE_ERR")  { e=EM_TARS_GET_PATCH_FILE_ERR; return 0;}
        if(s == "EM_TARS_PREPARE_ERR")  { e=EM_TARS_PREPARE_ERR; return 0;}
        if(s == "EM_TARS_UNKNOWN_ERR")  { e=EM_TARS_UNKNOWN_ERR; return 0;}
        if(s == "EM_TARS_SUCCESS")  { e=EM_TARS_SUCCESS; return 0;}

        return -1;
    }

    enum EMTaskCommand
    {
        EM_CMD_START,
        EM_CMD_STOP,
        EM_CMD_PATCH,
        EM_CMD_UNINSTALL,
    };
    inline string etos(const EMTaskCommand & e)
    {
        switch(e)
        {
            case EM_CMD_START: return "EM_CMD_START";
            case EM_CMD_STOP: return "EM_CMD_STOP";
            case EM_CMD_PATCH: return "EM_CMD_PATCH";
            case EM_CMD_UNINSTALL: return "EM_CMD_UNINSTALL";
            default: return "";
        }
    }
    inline int stoe(const string & s, EMTaskCommand & e)
    {
        if(s == "EM_CMD_START")  { e=EM_CMD_START; return 0;}
        if(s == "EM_CMD_STOP")  { e=EM_CMD_STOP; return 0;}
        if(s == "EM_CMD_PATCH")  { e=EM_CMD_PATCH; return 0;}
        if(s == "EM_CMD_UNINSTALL")  { e=EM_CMD_UNINSTALL; return 0;}

        return -1;
    }

    enum EMTaskStatus
    {
        EM_T_NOT_START,
        EM_T_RUNNING,
        EM_T_SUCCESS,
        EM_T_FAILED,
        EM_T_CANCEL,
        EM_T_PARIAL,
    };
    inline string etos(const EMTaskStatus & e)
    {
        switch(e)
        {
            case EM_T_NOT_START: return "EM_T_NOT_START";
            case EM_T_RUNNING: return "EM_T_RUNNING";
            case EM_T_SUCCESS: return "EM_T_SUCCESS";
            case EM_T_FAILED: return "EM_T_FAILED";
            case EM_T_CANCEL: return "EM_T_CANCEL";
            case EM_T_PARIAL: return "EM_T_PARIAL";
            default: return "";
        }
    }
    inline int stoe(const string & s, EMTaskStatus & e)
    {
        if(s == "EM_T_NOT_START")  { e=EM_T_NOT_START; return 0;}
        if(s == "EM_T_RUNNING")  { e=EM_T_RUNNING; return 0;}
        if(s == "EM_T_SUCCESS")  { e=EM_T_SUCCESS; return 0;}
        if(s == "EM_T_FAILED")  { e=EM_T_FAILED; return 0;}
        if(s == "EM_T_CANCEL")  { e=EM_T_CANCEL; return 0;}
        if(s == "EM_T_PARIAL")  { e=EM_T_PARIAL; return 0;}

        return -1;
    }

    enum EMTaskItemStatus
    {
        EM_I_NOT_START,
        EM_I_RUNNING,
        EM_I_SUCCESS,
        EM_I_FAILED,
        EM_I_CANCEL,
    };
    inline string etos(const EMTaskItemStatus & e)
    {
        switch(e)
        {
            case EM_I_NOT_START: return "EM_I_NOT_START";
            case EM_I_RUNNING: return "EM_I_RUNNING";
            case EM_I_SUCCESS: return "EM_I_SUCCESS";
            case EM_I_FAILED: return "EM_I_FAILED";
            case EM_I_CANCEL: return "EM_I_CANCEL";
            default: return "";
        }
    }
    inline int stoe(const string & s, EMTaskItemStatus & e)
    {
        if(s == "EM_I_NOT_START")  { e=EM_I_NOT_START; return 0;}
        if(s == "EM_I_RUNNING")  { e=EM_I_RUNNING; return 0;}
        if(s == "EM_I_SUCCESS")  { e=EM_I_SUCCESS; return 0;}
        if(s == "EM_I_FAILED")  { e=EM_I_FAILED; return 0;}
        if(s == "EM_I_CANCEL")  { e=EM_I_CANCEL; return 0;}

        return -1;
    }

    enum ServerGridStatus
    {
        NORMAL = 0,
        GRID = 1,
        NO_FLOW = 2,
    };
    inline string etos(const ServerGridStatus & e)
    {
        switch(e)
        {
            case NORMAL: return "NORMAL";
            case GRID: return "GRID";
            case NO_FLOW: return "NO_FLOW";
            default: return "";
        }
    }
    inline int stoe(const string & s, ServerGridStatus & e)
    {
        if(s == "NORMAL")  { e=NORMAL; return 0;}
        if(s == "GRID")  { e=GRID; return 0;}
        if(s == "NO_FLOW")  { e=NO_FLOW; return 0;}

        return -1;
    }

    struct ServerStateDesc : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.ServerStateDesc";
        }
        static string MD5()
        {
            return "26a898b86ec52b208c13f81a9242fcd3";
        }
        ServerStateDesc()
        :settingStateInReg(""),presentStateInReg(""),presentStateInNode(""),processId(0),patchVersion(""),patchTime(""),patchUser("")
        {
        }
        void resetDefautlt()
        {
            settingStateInReg = "";
            presentStateInReg = "";
            presentStateInNode = "";
            processId = 0;
            patchVersion = "";
            patchTime = "";
            patchUser = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(settingStateInReg, 0);
            _os.write(presentStateInReg, 1);
            _os.write(presentStateInNode, 2);
            _os.write(processId, 3);
            _os.write(patchVersion, 4);
            _os.write(patchTime, 5);
            _os.write(patchUser, 6);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(settingStateInReg, 0, true);
            _is.read(presentStateInReg, 1, true);
            _is.read(presentStateInNode, 2, true);
            _is.read(processId, 3, true);
            _is.read(patchVersion, 4, true);
            _is.read(patchTime, 5, true);
            _is.read(patchUser, 6, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(settingStateInReg,"settingStateInReg");
            _ds.display(presentStateInReg,"presentStateInReg");
            _ds.display(presentStateInNode,"presentStateInNode");
            _ds.display(processId,"processId");
            _ds.display(patchVersion,"patchVersion");
            _ds.display(patchTime,"patchTime");
            _ds.display(patchUser,"patchUser");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(settingStateInReg, true);
            _ds.displaySimple(presentStateInReg, true);
            _ds.displaySimple(presentStateInNode, true);
            _ds.displaySimple(processId, true);
            _ds.displaySimple(patchVersion, true);
            _ds.displaySimple(patchTime, true);
            _ds.displaySimple(patchUser, false);
            return _os;
        }
    public:
        std::string settingStateInReg;
        std::string presentStateInReg;
        std::string presentStateInNode;
        tars::Int32 processId;
        std::string patchVersion;
        std::string patchTime;
        std::string patchUser;
    };
    inline bool operator==(const ServerStateDesc&l, const ServerStateDesc&r)
    {
        return l.settingStateInReg == r.settingStateInReg && l.presentStateInReg == r.presentStateInReg && l.presentStateInNode == r.presentStateInNode && l.processId == r.processId && l.patchVersion == r.patchVersion && l.patchTime == r.patchTime && l.patchUser == r.patchUser;
    }
    inline bool operator!=(const ServerStateDesc&l, const ServerStateDesc&r)
    {
        return !(l == r);
    }

    struct TaskItemReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.TaskItemReq";
        }
        static string MD5()
        {
            return "81985ab5572d614277b48adc89fb3c33";
        }
        TaskItemReq()
        :taskNo(""),itemNo(""),application(""),serverName(""),nodeName(""),setName(""),command(""),userName("")
        {
        }
        void resetDefautlt()
        {
            taskNo = "";
            itemNo = "";
            application = "";
            serverName = "";
            nodeName = "";
            setName = "";
            command = "";
            userName = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (taskNo != "")
            {
                _os.write(taskNo, 0);
            }
            if (itemNo != "")
            {
                _os.write(itemNo, 1);
            }
            if (application != "")
            {
                _os.write(application, 2);
            }
            if (serverName != "")
            {
                _os.write(serverName, 3);
            }
            if (nodeName != "")
            {
                _os.write(nodeName, 4);
            }
            if (setName != "")
            {
                _os.write(setName, 5);
            }
            if (command != "")
            {
                _os.write(command, 6);
            }
            if (userName != "")
            {
                _os.write(userName, 7);
            }
            if (parameters.size() > 0)
            {
                _os.write(parameters, 8);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(taskNo, 0, false);
            _is.read(itemNo, 1, false);
            _is.read(application, 2, false);
            _is.read(serverName, 3, false);
            _is.read(nodeName, 4, false);
            _is.read(setName, 5, false);
            _is.read(command, 6, false);
            _is.read(userName, 7, false);
            _is.read(parameters, 8, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(taskNo,"taskNo");
            _ds.display(itemNo,"itemNo");
            _ds.display(application,"application");
            _ds.display(serverName,"serverName");
            _ds.display(nodeName,"nodeName");
            _ds.display(setName,"setName");
            _ds.display(command,"command");
            _ds.display(userName,"userName");
            _ds.display(parameters,"parameters");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(taskNo, true);
            _ds.displaySimple(itemNo, true);
            _ds.displaySimple(application, true);
            _ds.displaySimple(serverName, true);
            _ds.displaySimple(nodeName, true);
            _ds.displaySimple(setName, true);
            _ds.displaySimple(command, true);
            _ds.displaySimple(userName, true);
            _ds.displaySimple(parameters, false);
            return _os;
        }
    public:
        std::string taskNo;
        std::string itemNo;
        std::string application;
        std::string serverName;
        std::string nodeName;
        std::string setName;
        std::string command;
        std::string userName;
        map<std::string, std::string> parameters;
    };
    inline bool operator==(const TaskItemReq&l, const TaskItemReq&r)
    {
        return l.taskNo == r.taskNo && l.itemNo == r.itemNo && l.application == r.application && l.serverName == r.serverName && l.nodeName == r.nodeName && l.setName == r.setName && l.command == r.command && l.userName == r.userName && l.parameters == r.parameters;
    }
    inline bool operator!=(const TaskItemReq&l, const TaskItemReq&r)
    {
        return !(l == r);
    }

    struct TaskItemRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.TaskItemRsp";
        }
        static string MD5()
        {
            return "ba000f5325f58b82a399e8554779123e";
        }
        TaskItemRsp()
        :startTime(""),endTime(""),status(tars::EM_I_NOT_START),statusInfo(""),executeLog("")
        {
        }
        void resetDefautlt()
        {
            startTime = "";
            endTime = "";
            statusInfo = "";
            executeLog = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(req, 0);
            if (startTime != "")
            {
                _os.write(startTime, 1);
            }
            if (endTime != "")
            {
                _os.write(endTime, 2);
            }
            _os.write((tars::Int32)status, 3);
            if (statusInfo != "")
            {
                _os.write(statusInfo, 4);
            }
            if (executeLog != "")
            {
                _os.write(executeLog, 5);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(req, 0, false);
            _is.read(startTime, 1, false);
            _is.read(endTime, 2, false);
            tars::Int32 eTemp3 = tars::EM_I_NOT_START;
            _is.read(eTemp3, 3, false);
            status = (tars::EMTaskItemStatus)eTemp3;
            _is.read(statusInfo, 4, false);
            _is.read(executeLog, 5, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(req,"req");
            _ds.display(startTime,"startTime");
            _ds.display(endTime,"endTime");
            _ds.display((tars::Int32)status,"status");
            _ds.display(statusInfo,"statusInfo");
            _ds.display(executeLog,"executeLog");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(req, true);
            _ds.displaySimple(startTime, true);
            _ds.displaySimple(endTime, true);
            _ds.displaySimple((tars::Int32)status, true);
            _ds.displaySimple(statusInfo, true);
            _ds.displaySimple(executeLog, false);
            return _os;
        }
    public:
        tars::TaskItemReq req;
        std::string startTime;
        std::string endTime;
        tars::EMTaskItemStatus status;
        std::string statusInfo;
        std::string executeLog;
    };
    inline bool operator==(const TaskItemRsp&l, const TaskItemRsp&r)
    {
        return l.req == r.req && l.startTime == r.startTime && l.endTime == r.endTime && l.status == r.status && l.statusInfo == r.statusInfo && l.executeLog == r.executeLog;
    }
    inline bool operator!=(const TaskItemRsp&l, const TaskItemRsp&r)
    {
        return !(l == r);
    }

    struct TaskReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.TaskReq";
        }
        static string MD5()
        {
            return "85547c93e3d9c6c15404678e7549dc1c";
        }
        TaskReq()
        :taskNo(""),serial(true),userName("")
        {
        }
        void resetDefautlt()
        {
            taskNo = "";
            serial = true;
            userName = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (taskItemReq.size() > 0)
            {
                _os.write(taskItemReq, 0);
            }
            if (taskNo != "")
            {
                _os.write(taskNo, 1);
            }
            if (serial != true)
            {
                _os.write(serial, 2);
            }
            if (userName != "")
            {
                _os.write(userName, 3);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(taskItemReq, 0, false);
            _is.read(taskNo, 1, false);
            _is.read(serial, 2, false);
            _is.read(userName, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(taskItemReq,"taskItemReq");
            _ds.display(taskNo,"taskNo");
            _ds.display(serial,"serial");
            _ds.display(userName,"userName");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(taskItemReq, true);
            _ds.displaySimple(taskNo, true);
            _ds.displaySimple(serial, true);
            _ds.displaySimple(userName, false);
            return _os;
        }
    public:
        vector<tars::TaskItemReq> taskItemReq;
        std::string taskNo;
        tars::Bool serial;
        std::string userName;
    };
    inline bool operator==(const TaskReq&l, const TaskReq&r)
    {
        return l.taskItemReq == r.taskItemReq && l.taskNo == r.taskNo && l.serial == r.serial && l.userName == r.userName;
    }
    inline bool operator!=(const TaskReq&l, const TaskReq&r)
    {
        return !(l == r);
    }

    struct TaskRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.TaskRsp";
        }
        static string MD5()
        {
            return "6229b8205a75184a6cf577f2dc95946c";
        }
        TaskRsp()
        :taskNo(""),serial(true),userName(""),status(tars::EM_T_NOT_START)
        {
        }
        void resetDefautlt()
        {
            taskNo = "";
            serial = true;
            userName = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (taskItemRsp.size() > 0)
            {
                _os.write(taskItemRsp, 0);
            }
            if (taskNo != "")
            {
                _os.write(taskNo, 1);
            }
            if (serial != true)
            {
                _os.write(serial, 2);
            }
            if (userName != "")
            {
                _os.write(userName, 3);
            }
            _os.write((tars::Int32)status, 4);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(taskItemRsp, 0, false);
            _is.read(taskNo, 1, false);
            _is.read(serial, 2, false);
            _is.read(userName, 3, false);
            tars::Int32 eTemp4 = tars::EM_T_NOT_START;
            _is.read(eTemp4, 4, false);
            status = (tars::EMTaskStatus)eTemp4;
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(taskItemRsp,"taskItemRsp");
            _ds.display(taskNo,"taskNo");
            _ds.display(serial,"serial");
            _ds.display(userName,"userName");
            _ds.display((tars::Int32)status,"status");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(taskItemRsp, true);
            _ds.displaySimple(taskNo, true);
            _ds.displaySimple(serial, true);
            _ds.displaySimple(userName, true);
            _ds.displaySimple((tars::Int32)status, false);
            return _os;
        }
    public:
        vector<tars::TaskItemRsp> taskItemRsp;
        std::string taskNo;
        tars::Bool serial;
        std::string userName;
        tars::EMTaskStatus status;
    };
    inline bool operator==(const TaskRsp&l, const TaskRsp&r)
    {
        return l.taskItemRsp == r.taskItemRsp && l.taskNo == r.taskNo && l.serial == r.serial && l.userName == r.userName && l.status == r.status;
    }
    inline bool operator!=(const TaskRsp&l, const TaskRsp&r)
    {
        return !(l == r);
    }

    struct ServerGridDesc : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.ServerGridDesc";
        }
        static string MD5()
        {
            return "5dca8d8ce9ef37d050d052d9f4db0322";
        }
        ServerGridDesc()
        :application(""),servername(""),nodename(""),status(tars::NORMAL)
        {
        }
        void resetDefautlt()
        {
            application = "";
            servername = "";
            nodename = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(application, 0);
            _os.write(servername, 1);
            _os.write(nodename, 2);
            _os.write((tars::Int32)status, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(application, 0, true);
            _is.read(servername, 1, true);
            _is.read(nodename, 2, true);
            tars::Int32 eTemp3 = tars::NORMAL;
            _is.read(eTemp3, 3, true);
            status = (tars::ServerGridStatus)eTemp3;
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(application,"application");
            _ds.display(servername,"servername");
            _ds.display(nodename,"nodename");
            _ds.display((tars::Int32)status,"status");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(application, true);
            _ds.displaySimple(servername, true);
            _ds.displaySimple(nodename, true);
            _ds.displaySimple((tars::Int32)status, false);
            return _os;
        }
    public:
        std::string application;
        std::string servername;
        std::string nodename;
        tars::ServerGridStatus status;
    };
    inline bool operator==(const ServerGridDesc&l, const ServerGridDesc&r)
    {
        return l.application == r.application && l.servername == r.servername && l.nodename == r.nodename && l.status == r.status;
    }
    inline bool operator!=(const ServerGridDesc&l, const ServerGridDesc&r)
    {
        return !(l == r);
    }


    /* callback of async proxy for client */
    class AdminRegPrxCallback: public tars::ServantProxyCallback
    {
    public:
        virtual ~AdminRegPrxCallback(){}
        virtual void callback_addTaskReq(tars::Int32 ret)
        { throw std::runtime_error("callback_addTaskReq() override incorrect."); }
        virtual void callback_addTaskReq_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_addTaskReq_exception() override incorrect."); }

        virtual void callback_batchPatch(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_batchPatch() override incorrect."); }
        virtual void callback_batchPatch_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_batchPatch_exception() override incorrect."); }

        virtual void callback_getAllApplicationNames(const vector<std::string>& ret,  const std::string& result)
        { throw std::runtime_error("callback_getAllApplicationNames() override incorrect."); }
        virtual void callback_getAllApplicationNames_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getAllApplicationNames_exception() override incorrect."); }

        virtual void callback_getAllNodeNames(const vector<std::string>& ret,  const std::string& result)
        { throw std::runtime_error("callback_getAllNodeNames() override incorrect."); }
        virtual void callback_getAllNodeNames_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getAllNodeNames_exception() override incorrect."); }

        virtual void callback_getAllServerIds(const vector<vector<std::string> >& ret,  const std::string& result)
        { throw std::runtime_error("callback_getAllServerIds() override incorrect."); }
        virtual void callback_getAllServerIds_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getAllServerIds_exception() override incorrect."); }

        virtual void callback_getClientIp(tars::Int32 ret,  const std::string& sClientIp)
        { throw std::runtime_error("callback_getClientIp() override incorrect."); }
        virtual void callback_getClientIp_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getClientIp_exception() override incorrect."); }

        virtual void callback_getGroupId(tars::Int32 ret, tars::Int32 groupId,  const std::string& result)
        { throw std::runtime_error("callback_getGroupId() override incorrect."); }
        virtual void callback_getGroupId_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getGroupId_exception() override incorrect."); }

        virtual void callback_getNodeVesion(tars::Int32 ret,  const std::string& version,  const std::string& result)
        { throw std::runtime_error("callback_getNodeVesion() override incorrect."); }
        virtual void callback_getNodeVesion_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getNodeVesion_exception() override incorrect."); }

        virtual void callback_getPatchPercent(tars::Int32 ret,  const tars::PatchInfo& tPatchInfo)
        { throw std::runtime_error("callback_getPatchPercent() override incorrect."); }
        virtual void callback_getPatchPercent_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getPatchPercent_exception() override incorrect."); }

        virtual void callback_getProfileTemplate(tars::Int32 ret,  const std::string& profileTemplate,  const std::string& resultDesc)
        { throw std::runtime_error("callback_getProfileTemplate() override incorrect."); }
        virtual void callback_getProfileTemplate_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getProfileTemplate_exception() override incorrect."); }

        virtual void callback_getServerProfileTemplate(tars::Int32 ret,  const std::string& profileTemplate,  const std::string& resultDesc)
        { throw std::runtime_error("callback_getServerProfileTemplate() override incorrect."); }
        virtual void callback_getServerProfileTemplate_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getServerProfileTemplate_exception() override incorrect."); }

        virtual void callback_getServerState(tars::Int32 ret,  const tars::ServerStateDesc& state,  const std::string& result)
        { throw std::runtime_error("callback_getServerState() override incorrect."); }
        virtual void callback_getServerState_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getServerState_exception() override incorrect."); }

        virtual void callback_getTaskHistory(tars::Int32 ret,  const vector<tars::TaskRsp>& taskRsps)
        { throw std::runtime_error("callback_getTaskHistory() override incorrect."); }
        virtual void callback_getTaskHistory_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getTaskHistory_exception() override incorrect."); }

        virtual void callback_getTaskRsp(tars::Int32 ret,  const tars::TaskRsp& taskRsp)
        { throw std::runtime_error("callback_getTaskRsp() override incorrect."); }
        virtual void callback_getTaskRsp_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getTaskRsp_exception() override incorrect."); }

        virtual void callback_gridPatchServer(tars::Int32 ret,  const vector<tars::ServerGridDesc>& gridFailDescList,  const std::string& resultDesc)
        { throw std::runtime_error("callback_gridPatchServer() override incorrect."); }
        virtual void callback_gridPatchServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_gridPatchServer_exception() override incorrect."); }

        virtual void callback_loadServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_loadServer() override incorrect."); }
        virtual void callback_loadServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_loadServer_exception() override incorrect."); }

        virtual void callback_notifyServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_notifyServer() override incorrect."); }
        virtual void callback_notifyServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_notifyServer_exception() override incorrect."); }

        virtual void callback_pingNode(tars::Bool ret,  const std::string& result)
        { throw std::runtime_error("callback_pingNode() override incorrect."); }
        virtual void callback_pingNode_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_pingNode_exception() override incorrect."); }

        virtual void callback_restartServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_restartServer() override incorrect."); }
        virtual void callback_restartServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_restartServer_exception() override incorrect."); }

        virtual void callback_setTaskItemInfo(tars::Int32 ret)
        { throw std::runtime_error("callback_setTaskItemInfo() override incorrect."); }
        virtual void callback_setTaskItemInfo_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_setTaskItemInfo_exception() override incorrect."); }

        virtual void callback_shutdownNode(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_shutdownNode() override incorrect."); }
        virtual void callback_shutdownNode_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_shutdownNode_exception() override incorrect."); }

        virtual void callback_startServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_startServer() override incorrect."); }
        virtual void callback_startServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_startServer_exception() override incorrect."); }

        virtual void callback_stopServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_stopServer() override incorrect."); }
        virtual void callback_stopServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_stopServer_exception() override incorrect."); }

        virtual void callback_undeploy(tars::Int32 ret,  const std::string& log)
        { throw std::runtime_error("callback_undeploy() override incorrect."); }
        virtual void callback_undeploy_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_undeploy_exception() override incorrect."); }

        virtual void callback_updatePatchLog(tars::Int32 ret)
        { throw std::runtime_error("callback_updatePatchLog() override incorrect."); }
        virtual void callback_updatePatchLog_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_updatePatchLog_exception() override incorrect."); }

    public:
        virtual const map<std::string, std::string> & getResponseContext() const
        {
            CallbackThreadData * pCbtd = CallbackThreadData::getData();
            assert(pCbtd != NULL);

            if(!pCbtd->getContextValid())
            {
                throw TC_Exception("cann't get response context");
            }
            return pCbtd->getResponseContext();
        }

    public:
        virtual int onDispatch(tars::ReqMessagePtr msg)
        {
            static ::std::string __AdminReg_all[]=
            {
                "addTaskReq",
                "batchPatch",
                "getAllApplicationNames",
                "getAllNodeNames",
                "getAllServerIds",
                "getClientIp",
                "getGroupId",
                "getNodeVesion",
                "getPatchPercent",
                "getProfileTemplate",
                "getServerProfileTemplate",
                "getServerState",
                "getTaskHistory",
                "getTaskRsp",
                "gridPatchServer",
                "loadServer",
                "notifyServer",
                "pingNode",
                "restartServer",
                "setTaskItemInfo",
                "shutdownNode",
                "startServer",
                "stopServer",
                "undeploy",
                "updatePatchLog"
            };
            pair<string*, string*> r = equal_range(__AdminReg_all, __AdminReg_all+25, string(msg->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __AdminReg_all)
            {
                case 0:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_addTaskReq_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_addTaskReq(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_batchPatch_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_batchPatch(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getAllApplicationNames_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    vector<std::string> _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_getAllApplicationNames(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getAllNodeNames_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    vector<std::string> _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_getAllNodeNames(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getAllServerIds_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    vector<vector<std::string> > _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_getAllServerIds(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getClientIp_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string sClientIp;
                    _is.read(sClientIp, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_getClientIp(_ret, sClientIp);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getGroupId_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::Int32 groupId;
                    _is.read(groupId, 2, true);
                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_getGroupId(_ret, groupId, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getNodeVesion_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string version;
                    _is.read(version, 2, true);
                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_getNodeVesion(_ret, version, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getPatchPercent_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::PatchInfo tPatchInfo;
                    _is.read(tPatchInfo, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_getPatchPercent(_ret, tPatchInfo);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getProfileTemplate_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string profileTemplate;
                    _is.read(profileTemplate, 2, true);
                    std::string resultDesc;
                    _is.read(resultDesc, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_getProfileTemplate(_ret, profileTemplate, resultDesc);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServerProfileTemplate_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string profileTemplate;
                    _is.read(profileTemplate, 4, true);
                    std::string resultDesc;
                    _is.read(resultDesc, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_getServerProfileTemplate(_ret, profileTemplate, resultDesc);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServerState_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::ServerStateDesc state;
                    _is.read(state, 4, true);
                    std::string result;
                    _is.read(result, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_getServerState(_ret, state, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getTaskHistory_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<tars::TaskRsp> taskRsps;
                    _is.read(taskRsps, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_getTaskHistory(_ret, taskRsps);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getTaskRsp_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::TaskRsp taskRsp;
                    _is.read(taskRsp, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_getTaskRsp(_ret, taskRsp);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_gridPatchServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<tars::ServerGridDesc> gridFailDescList;
                    _is.read(gridFailDescList, 2, true);
                    std::string resultDesc;
                    _is.read(resultDesc, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_gridPatchServer(_ret, gridFailDescList, resultDesc);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 15:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_loadServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_loadServer(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 16:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_notifyServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_notifyServer(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 17:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_pingNode_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_pingNode(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 18:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_restartServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_restartServer(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 19:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_setTaskItemInfo_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_setTaskItemInfo(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 20:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_shutdownNode_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_shutdownNode(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 21:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_startServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_startServer(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 22:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_stopServer(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 23:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_undeploy_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string log;
                    _is.read(log, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_undeploy(_ret, log);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 24:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_updatePatchLog_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_updatePatchLog(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<AdminRegPrxCallback> AdminRegPrxCallbackPtr;

    /* callback of promise async proxy for client */
    class AdminRegPrxCallbackPromise: public tars::ServantProxyCallback
    {
    public:
        virtual ~AdminRegPrxCallbackPromise(){}
    public:
        struct PromiseaddTaskReq: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromiseaddTaskReq > PromiseaddTaskReqPtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromiseaddTaskReqPtr > &promise)
        : _promise_addTaskReq(promise)
        {}
        
        virtual void callback_addTaskReq(const AdminRegPrxCallbackPromise::PromiseaddTaskReqPtr &ptr)
        {
            _promise_addTaskReq.setValue(ptr);
        }
        virtual void callback_addTaskReq_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:addTaskReq_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_addTaskReq.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromiseaddTaskReqPtr > _promise_addTaskReq;

    public:
        struct PromisebatchPatch: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisebatchPatch > PromisebatchPatchPtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromisebatchPatchPtr > &promise)
        : _promise_batchPatch(promise)
        {}
        
        virtual void callback_batchPatch(const AdminRegPrxCallbackPromise::PromisebatchPatchPtr &ptr)
        {
            _promise_batchPatch.setValue(ptr);
        }
        virtual void callback_batchPatch_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:batchPatch_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_batchPatch.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromisebatchPatchPtr > _promise_batchPatch;

    public:
        struct PromisegetAllApplicationNames: virtual public TC_HandleBase
        {
        public:
            vector<std::string> _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetAllApplicationNames > PromisegetAllApplicationNamesPtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromisegetAllApplicationNamesPtr > &promise)
        : _promise_getAllApplicationNames(promise)
        {}
        
        virtual void callback_getAllApplicationNames(const AdminRegPrxCallbackPromise::PromisegetAllApplicationNamesPtr &ptr)
        {
            _promise_getAllApplicationNames.setValue(ptr);
        }
        virtual void callback_getAllApplicationNames_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getAllApplicationNames_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getAllApplicationNames.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromisegetAllApplicationNamesPtr > _promise_getAllApplicationNames;

    public:
        struct PromisegetAllNodeNames: virtual public TC_HandleBase
        {
        public:
            vector<std::string> _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetAllNodeNames > PromisegetAllNodeNamesPtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromisegetAllNodeNamesPtr > &promise)
        : _promise_getAllNodeNames(promise)
        {}
        
        virtual void callback_getAllNodeNames(const AdminRegPrxCallbackPromise::PromisegetAllNodeNamesPtr &ptr)
        {
            _promise_getAllNodeNames.setValue(ptr);
        }
        virtual void callback_getAllNodeNames_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getAllNodeNames_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getAllNodeNames.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromisegetAllNodeNamesPtr > _promise_getAllNodeNames;

    public:
        struct PromisegetAllServerIds: virtual public TC_HandleBase
        {
        public:
            vector<vector<std::string> > _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetAllServerIds > PromisegetAllServerIdsPtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromisegetAllServerIdsPtr > &promise)
        : _promise_getAllServerIds(promise)
        {}
        
        virtual void callback_getAllServerIds(const AdminRegPrxCallbackPromise::PromisegetAllServerIdsPtr &ptr)
        {
            _promise_getAllServerIds.setValue(ptr);
        }
        virtual void callback_getAllServerIds_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getAllServerIds_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getAllServerIds.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromisegetAllServerIdsPtr > _promise_getAllServerIds;

    public:
        struct PromisegetClientIp: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string sClientIp;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetClientIp > PromisegetClientIpPtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromisegetClientIpPtr > &promise)
        : _promise_getClientIp(promise)
        {}
        
        virtual void callback_getClientIp(const AdminRegPrxCallbackPromise::PromisegetClientIpPtr &ptr)
        {
            _promise_getClientIp.setValue(ptr);
        }
        virtual void callback_getClientIp_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getClientIp_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getClientIp.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromisegetClientIpPtr > _promise_getClientIp;

    public:
        struct PromisegetGroupId: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::Int32 groupId;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetGroupId > PromisegetGroupIdPtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromisegetGroupIdPtr > &promise)
        : _promise_getGroupId(promise)
        {}
        
        virtual void callback_getGroupId(const AdminRegPrxCallbackPromise::PromisegetGroupIdPtr &ptr)
        {
            _promise_getGroupId.setValue(ptr);
        }
        virtual void callback_getGroupId_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getGroupId_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getGroupId.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromisegetGroupIdPtr > _promise_getGroupId;

    public:
        struct PromisegetNodeVesion: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string version;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetNodeVesion > PromisegetNodeVesionPtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromisegetNodeVesionPtr > &promise)
        : _promise_getNodeVesion(promise)
        {}
        
        virtual void callback_getNodeVesion(const AdminRegPrxCallbackPromise::PromisegetNodeVesionPtr &ptr)
        {
            _promise_getNodeVesion.setValue(ptr);
        }
        virtual void callback_getNodeVesion_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getNodeVesion_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getNodeVesion.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromisegetNodeVesionPtr > _promise_getNodeVesion;

    public:
        struct PromisegetPatchPercent: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::PatchInfo tPatchInfo;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetPatchPercent > PromisegetPatchPercentPtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromisegetPatchPercentPtr > &promise)
        : _promise_getPatchPercent(promise)
        {}
        
        virtual void callback_getPatchPercent(const AdminRegPrxCallbackPromise::PromisegetPatchPercentPtr &ptr)
        {
            _promise_getPatchPercent.setValue(ptr);
        }
        virtual void callback_getPatchPercent_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getPatchPercent_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getPatchPercent.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromisegetPatchPercentPtr > _promise_getPatchPercent;

    public:
        struct PromisegetProfileTemplate: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string profileTemplate;
            std::string resultDesc;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetProfileTemplate > PromisegetProfileTemplatePtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromisegetProfileTemplatePtr > &promise)
        : _promise_getProfileTemplate(promise)
        {}
        
        virtual void callback_getProfileTemplate(const AdminRegPrxCallbackPromise::PromisegetProfileTemplatePtr &ptr)
        {
            _promise_getProfileTemplate.setValue(ptr);
        }
        virtual void callback_getProfileTemplate_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getProfileTemplate_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getProfileTemplate.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromisegetProfileTemplatePtr > _promise_getProfileTemplate;

    public:
        struct PromisegetServerProfileTemplate: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string profileTemplate;
            std::string resultDesc;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetServerProfileTemplate > PromisegetServerProfileTemplatePtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromisegetServerProfileTemplatePtr > &promise)
        : _promise_getServerProfileTemplate(promise)
        {}
        
        virtual void callback_getServerProfileTemplate(const AdminRegPrxCallbackPromise::PromisegetServerProfileTemplatePtr &ptr)
        {
            _promise_getServerProfileTemplate.setValue(ptr);
        }
        virtual void callback_getServerProfileTemplate_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getServerProfileTemplate_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getServerProfileTemplate.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromisegetServerProfileTemplatePtr > _promise_getServerProfileTemplate;

    public:
        struct PromisegetServerState: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::ServerStateDesc state;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetServerState > PromisegetServerStatePtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromisegetServerStatePtr > &promise)
        : _promise_getServerState(promise)
        {}
        
        virtual void callback_getServerState(const AdminRegPrxCallbackPromise::PromisegetServerStatePtr &ptr)
        {
            _promise_getServerState.setValue(ptr);
        }
        virtual void callback_getServerState_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getServerState_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getServerState.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromisegetServerStatePtr > _promise_getServerState;

    public:
        struct PromisegetTaskHistory: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            vector<tars::TaskRsp> taskRsps;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetTaskHistory > PromisegetTaskHistoryPtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromisegetTaskHistoryPtr > &promise)
        : _promise_getTaskHistory(promise)
        {}
        
        virtual void callback_getTaskHistory(const AdminRegPrxCallbackPromise::PromisegetTaskHistoryPtr &ptr)
        {
            _promise_getTaskHistory.setValue(ptr);
        }
        virtual void callback_getTaskHistory_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getTaskHistory_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getTaskHistory.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromisegetTaskHistoryPtr > _promise_getTaskHistory;

    public:
        struct PromisegetTaskRsp: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::TaskRsp taskRsp;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegetTaskRsp > PromisegetTaskRspPtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromisegetTaskRspPtr > &promise)
        : _promise_getTaskRsp(promise)
        {}
        
        virtual void callback_getTaskRsp(const AdminRegPrxCallbackPromise::PromisegetTaskRspPtr &ptr)
        {
            _promise_getTaskRsp.setValue(ptr);
        }
        virtual void callback_getTaskRsp_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getTaskRsp_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getTaskRsp.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromisegetTaskRspPtr > _promise_getTaskRsp;

    public:
        struct PromisegridPatchServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            vector<tars::ServerGridDesc> gridFailDescList;
            std::string resultDesc;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisegridPatchServer > PromisegridPatchServerPtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromisegridPatchServerPtr > &promise)
        : _promise_gridPatchServer(promise)
        {}
        
        virtual void callback_gridPatchServer(const AdminRegPrxCallbackPromise::PromisegridPatchServerPtr &ptr)
        {
            _promise_gridPatchServer.setValue(ptr);
        }
        virtual void callback_gridPatchServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:gridPatchServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_gridPatchServer.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromisegridPatchServerPtr > _promise_gridPatchServer;

    public:
        struct PromiseloadServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromiseloadServer > PromiseloadServerPtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromiseloadServerPtr > &promise)
        : _promise_loadServer(promise)
        {}
        
        virtual void callback_loadServer(const AdminRegPrxCallbackPromise::PromiseloadServerPtr &ptr)
        {
            _promise_loadServer.setValue(ptr);
        }
        virtual void callback_loadServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:loadServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_loadServer.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromiseloadServerPtr > _promise_loadServer;

    public:
        struct PromisenotifyServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisenotifyServer > PromisenotifyServerPtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromisenotifyServerPtr > &promise)
        : _promise_notifyServer(promise)
        {}
        
        virtual void callback_notifyServer(const AdminRegPrxCallbackPromise::PromisenotifyServerPtr &ptr)
        {
            _promise_notifyServer.setValue(ptr);
        }
        virtual void callback_notifyServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:notifyServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_notifyServer.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromisenotifyServerPtr > _promise_notifyServer;

    public:
        struct PromisepingNode: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisepingNode > PromisepingNodePtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromisepingNodePtr > &promise)
        : _promise_pingNode(promise)
        {}
        
        virtual void callback_pingNode(const AdminRegPrxCallbackPromise::PromisepingNodePtr &ptr)
        {
            _promise_pingNode.setValue(ptr);
        }
        virtual void callback_pingNode_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:pingNode_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_pingNode.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromisepingNodePtr > _promise_pingNode;

    public:
        struct PromiserestartServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromiserestartServer > PromiserestartServerPtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromiserestartServerPtr > &promise)
        : _promise_restartServer(promise)
        {}
        
        virtual void callback_restartServer(const AdminRegPrxCallbackPromise::PromiserestartServerPtr &ptr)
        {
            _promise_restartServer.setValue(ptr);
        }
        virtual void callback_restartServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:restartServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_restartServer.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromiserestartServerPtr > _promise_restartServer;

    public:
        struct PromisesetTaskItemInfo: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisesetTaskItemInfo > PromisesetTaskItemInfoPtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromisesetTaskItemInfoPtr > &promise)
        : _promise_setTaskItemInfo(promise)
        {}
        
        virtual void callback_setTaskItemInfo(const AdminRegPrxCallbackPromise::PromisesetTaskItemInfoPtr &ptr)
        {
            _promise_setTaskItemInfo.setValue(ptr);
        }
        virtual void callback_setTaskItemInfo_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:setTaskItemInfo_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_setTaskItemInfo.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromisesetTaskItemInfoPtr > _promise_setTaskItemInfo;

    public:
        struct PromiseshutdownNode: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromiseshutdownNode > PromiseshutdownNodePtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromiseshutdownNodePtr > &promise)
        : _promise_shutdownNode(promise)
        {}
        
        virtual void callback_shutdownNode(const AdminRegPrxCallbackPromise::PromiseshutdownNodePtr &ptr)
        {
            _promise_shutdownNode.setValue(ptr);
        }
        virtual void callback_shutdownNode_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:shutdownNode_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_shutdownNode.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromiseshutdownNodePtr > _promise_shutdownNode;

    public:
        struct PromisestartServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisestartServer > PromisestartServerPtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromisestartServerPtr > &promise)
        : _promise_startServer(promise)
        {}
        
        virtual void callback_startServer(const AdminRegPrxCallbackPromise::PromisestartServerPtr &ptr)
        {
            _promise_startServer.setValue(ptr);
        }
        virtual void callback_startServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:startServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_startServer.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromisestartServerPtr > _promise_startServer;

    public:
        struct PromisestopServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromisestopServer > PromisestopServerPtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromisestopServerPtr > &promise)
        : _promise_stopServer(promise)
        {}
        
        virtual void callback_stopServer(const AdminRegPrxCallbackPromise::PromisestopServerPtr &ptr)
        {
            _promise_stopServer.setValue(ptr);
        }
        virtual void callback_stopServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:stopServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_stopServer.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromisestopServerPtr > _promise_stopServer;

    public:
        struct Promiseundeploy: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string log;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::Promiseundeploy > PromiseundeployPtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromiseundeployPtr > &promise)
        : _promise_undeploy(promise)
        {}
        
        virtual void callback_undeploy(const AdminRegPrxCallbackPromise::PromiseundeployPtr &ptr)
        {
            _promise_undeploy.setValue(ptr);
        }
        virtual void callback_undeploy_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:undeploy_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_undeploy.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromiseundeployPtr > _promise_undeploy;

    public:
        struct PromiseupdatePatchLog: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< AdminRegPrxCallbackPromise::PromiseupdatePatchLog > PromiseupdatePatchLogPtr;

        AdminRegPrxCallbackPromise(const promise::Promise< AdminRegPrxCallbackPromise::PromiseupdatePatchLogPtr > &promise)
        : _promise_updatePatchLog(promise)
        {}
        
        virtual void callback_updatePatchLog(const AdminRegPrxCallbackPromise::PromiseupdatePatchLogPtr &ptr)
        {
            _promise_updatePatchLog.setValue(ptr);
        }
        virtual void callback_updatePatchLog_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:updatePatchLog_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_updatePatchLog.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AdminRegPrxCallbackPromise::PromiseupdatePatchLogPtr > _promise_updatePatchLog;

    public:
        virtual int onDispatch(tars::ReqMessagePtr msg)
        {
            static ::std::string __AdminReg_all[]=
            {
                "addTaskReq",
                "batchPatch",
                "getAllApplicationNames",
                "getAllNodeNames",
                "getAllServerIds",
                "getClientIp",
                "getGroupId",
                "getNodeVesion",
                "getPatchPercent",
                "getProfileTemplate",
                "getServerProfileTemplate",
                "getServerState",
                "getTaskHistory",
                "getTaskRsp",
                "gridPatchServer",
                "loadServer",
                "notifyServer",
                "pingNode",
                "restartServer",
                "setTaskItemInfo",
                "shutdownNode",
                "startServer",
                "stopServer",
                "undeploy",
                "updatePatchLog"
            };

            pair<string*, string*> r = equal_range(__AdminReg_all, __AdminReg_all+25, string(msg->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __AdminReg_all)
            {
                case 0:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_addTaskReq_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromiseaddTaskReqPtr ptr = new AdminRegPrxCallbackPromise::PromiseaddTaskReq();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_addTaskReq_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_addTaskReq_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_addTaskReq(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_batchPatch_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromisebatchPatchPtr ptr = new AdminRegPrxCallbackPromise::PromisebatchPatch();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_batchPatch_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_batchPatch_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_batchPatch(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getAllApplicationNames_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetAllApplicationNamesPtr ptr = new AdminRegPrxCallbackPromise::PromisegetAllApplicationNames();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getAllApplicationNames_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getAllApplicationNames_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_getAllApplicationNames(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getAllNodeNames_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetAllNodeNamesPtr ptr = new AdminRegPrxCallbackPromise::PromisegetAllNodeNames();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getAllNodeNames_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getAllNodeNames_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_getAllNodeNames(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getAllServerIds_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetAllServerIdsPtr ptr = new AdminRegPrxCallbackPromise::PromisegetAllServerIds();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getAllServerIds_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getAllServerIds_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_getAllServerIds(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getClientIp_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetClientIpPtr ptr = new AdminRegPrxCallbackPromise::PromisegetClientIp();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->sClientIp, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getClientIp_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getClientIp_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_getClientIp(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getGroupId_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetGroupIdPtr ptr = new AdminRegPrxCallbackPromise::PromisegetGroupId();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->groupId, 2, true);
                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getGroupId_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getGroupId_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_getGroupId(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getNodeVesion_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetNodeVesionPtr ptr = new AdminRegPrxCallbackPromise::PromisegetNodeVesion();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->version, 2, true);
                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getNodeVesion_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getNodeVesion_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_getNodeVesion(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getPatchPercent_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetPatchPercentPtr ptr = new AdminRegPrxCallbackPromise::PromisegetPatchPercent();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->tPatchInfo, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getPatchPercent_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getPatchPercent_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_getPatchPercent(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getProfileTemplate_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetProfileTemplatePtr ptr = new AdminRegPrxCallbackPromise::PromisegetProfileTemplate();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->profileTemplate, 2, true);
                        _is.read(ptr->resultDesc, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getProfileTemplate_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getProfileTemplate_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_getProfileTemplate(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServerProfileTemplate_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetServerProfileTemplatePtr ptr = new AdminRegPrxCallbackPromise::PromisegetServerProfileTemplate();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->profileTemplate, 4, true);
                        _is.read(ptr->resultDesc, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getServerProfileTemplate_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServerProfileTemplate_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_getServerProfileTemplate(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServerState_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetServerStatePtr ptr = new AdminRegPrxCallbackPromise::PromisegetServerState();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->state, 4, true);
                        _is.read(ptr->result, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getServerState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServerState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_getServerState(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getTaskHistory_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetTaskHistoryPtr ptr = new AdminRegPrxCallbackPromise::PromisegetTaskHistory();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->taskRsps, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getTaskHistory_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getTaskHistory_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_getTaskHistory(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getTaskRsp_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromisegetTaskRspPtr ptr = new AdminRegPrxCallbackPromise::PromisegetTaskRsp();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->taskRsp, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getTaskRsp_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getTaskRsp_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_getTaskRsp(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_gridPatchServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromisegridPatchServerPtr ptr = new AdminRegPrxCallbackPromise::PromisegridPatchServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->gridFailDescList, 2, true);
                        _is.read(ptr->resultDesc, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_gridPatchServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_gridPatchServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_gridPatchServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 15:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_loadServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromiseloadServerPtr ptr = new AdminRegPrxCallbackPromise::PromiseloadServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_loadServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_loadServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_loadServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 16:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_notifyServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromisenotifyServerPtr ptr = new AdminRegPrxCallbackPromise::PromisenotifyServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_notifyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_notifyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_notifyServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 17:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_pingNode_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromisepingNodePtr ptr = new AdminRegPrxCallbackPromise::PromisepingNode();

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_pingNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_pingNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_pingNode(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 18:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_restartServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromiserestartServerPtr ptr = new AdminRegPrxCallbackPromise::PromiserestartServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_restartServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_restartServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_restartServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 19:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_setTaskItemInfo_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromisesetTaskItemInfoPtr ptr = new AdminRegPrxCallbackPromise::PromisesetTaskItemInfo();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_setTaskItemInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_setTaskItemInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_setTaskItemInfo(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 20:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_shutdownNode_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromiseshutdownNodePtr ptr = new AdminRegPrxCallbackPromise::PromiseshutdownNode();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_shutdownNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_shutdownNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_shutdownNode(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 21:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_startServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromisestartServerPtr ptr = new AdminRegPrxCallbackPromise::PromisestartServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_startServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_startServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_startServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 22:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromisestopServerPtr ptr = new AdminRegPrxCallbackPromise::PromisestopServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_stopServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_stopServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 23:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_undeploy_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromiseundeployPtr ptr = new AdminRegPrxCallbackPromise::Promiseundeploy();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->log, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_undeploy_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_undeploy_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_undeploy(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 24:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_updatePatchLog_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    AdminRegPrxCallbackPromise::PromiseupdatePatchLogPtr ptr = new AdminRegPrxCallbackPromise::PromiseupdatePatchLog();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_updatePatchLog_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_updatePatchLog_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_updatePatchLog(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<AdminRegPrxCallbackPromise> AdminRegPrxCallbackPromisePtr;

    /* callback of coroutine async proxy for client */
    class AdminRegCoroPrxCallback: public AdminRegPrxCallback
    {
    public:
        virtual ~AdminRegCoroPrxCallback(){}
    public:
        virtual const map<std::string, std::string> & getResponseContext() const { return _mRspContext; }

        virtual void setResponseContext(const map<std::string, std::string> &mContext) { _mRspContext = mContext; }

    public:
        int onDispatch(tars::ReqMessagePtr msg)
        {
            static ::std::string __AdminReg_all[]=
            {
                "addTaskReq",
                "batchPatch",
                "getAllApplicationNames",
                "getAllNodeNames",
                "getAllServerIds",
                "getClientIp",
                "getGroupId",
                "getNodeVesion",
                "getPatchPercent",
                "getProfileTemplate",
                "getServerProfileTemplate",
                "getServerState",
                "getTaskHistory",
                "getTaskRsp",
                "gridPatchServer",
                "loadServer",
                "notifyServer",
                "pingNode",
                "restartServer",
                "setTaskItemInfo",
                "shutdownNode",
                "startServer",
                "stopServer",
                "undeploy",
                "updatePatchLog"
            };

            pair<string*, string*> r = equal_range(__AdminReg_all, __AdminReg_all+25, string(msg->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __AdminReg_all)
            {
                case 0:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_addTaskReq_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(msg->response.context);

                        callback_addTaskReq(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_addTaskReq_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_addTaskReq_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_batchPatch_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 2, true);
                        setResponseContext(msg->response.context);

                        callback_batchPatch(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_batchPatch_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_batchPatch_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getAllApplicationNames_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        vector<std::string> _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 1, true);
                        setResponseContext(msg->response.context);

                        callback_getAllApplicationNames(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getAllApplicationNames_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getAllApplicationNames_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getAllNodeNames_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        vector<std::string> _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 1, true);
                        setResponseContext(msg->response.context);

                        callback_getAllNodeNames(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getAllNodeNames_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getAllNodeNames_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getAllServerIds_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        vector<vector<std::string> > _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 1, true);
                        setResponseContext(msg->response.context);

                        callback_getAllServerIds(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getAllServerIds_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getAllServerIds_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getClientIp_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string sClientIp;
                        _is.read(sClientIp, 1, true);
                        setResponseContext(msg->response.context);

                        callback_getClientIp(_ret, sClientIp);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getClientIp_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getClientIp_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getGroupId_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::Int32 groupId;
                        _is.read(groupId, 2, true);
                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(msg->response.context);

                        callback_getGroupId(_ret, groupId, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getGroupId_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getGroupId_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getNodeVesion_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string version;
                        _is.read(version, 2, true);
                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(msg->response.context);

                        callback_getNodeVesion(_ret, version, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getNodeVesion_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getNodeVesion_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getPatchPercent_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::PatchInfo tPatchInfo;
                        _is.read(tPatchInfo, 4, true);
                        setResponseContext(msg->response.context);

                        callback_getPatchPercent(_ret, tPatchInfo);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getPatchPercent_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getPatchPercent_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getProfileTemplate_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string profileTemplate;
                        _is.read(profileTemplate, 2, true);
                        std::string resultDesc;
                        _is.read(resultDesc, 3, true);
                        setResponseContext(msg->response.context);

                        callback_getProfileTemplate(_ret, profileTemplate, resultDesc);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getProfileTemplate_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getProfileTemplate_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServerProfileTemplate_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string profileTemplate;
                        _is.read(profileTemplate, 4, true);
                        std::string resultDesc;
                        _is.read(resultDesc, 5, true);
                        setResponseContext(msg->response.context);

                        callback_getServerProfileTemplate(_ret, profileTemplate, resultDesc);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getServerProfileTemplate_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServerProfileTemplate_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServerState_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::ServerStateDesc state;
                        _is.read(state, 4, true);
                        std::string result;
                        _is.read(result, 5, true);
                        setResponseContext(msg->response.context);

                        callback_getServerState(_ret, state, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getServerState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServerState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getTaskHistory_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<tars::TaskRsp> taskRsps;
                        _is.read(taskRsps, 4, true);
                        setResponseContext(msg->response.context);

                        callback_getTaskHistory(_ret, taskRsps);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getTaskHistory_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getTaskHistory_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getTaskRsp_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::TaskRsp taskRsp;
                        _is.read(taskRsp, 2, true);
                        setResponseContext(msg->response.context);

                        callback_getTaskRsp(_ret, taskRsp);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getTaskRsp_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getTaskRsp_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_gridPatchServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<tars::ServerGridDesc> gridFailDescList;
                        _is.read(gridFailDescList, 2, true);
                        std::string resultDesc;
                        _is.read(resultDesc, 3, true);
                        setResponseContext(msg->response.context);

                        callback_gridPatchServer(_ret, gridFailDescList, resultDesc);

                    }
                    catch(std::exception &ex)
                    {
                        callback_gridPatchServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_gridPatchServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 15:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_loadServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(msg->response.context);

                        callback_loadServer(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_loadServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_loadServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 16:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_notifyServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 5, true);
                        setResponseContext(msg->response.context);

                        callback_notifyServer(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_notifyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_notifyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 17:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_pingNode_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 2, true);
                        setResponseContext(msg->response.context);

                        callback_pingNode(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_pingNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_pingNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 18:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_restartServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(msg->response.context);

                        callback_restartServer(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_restartServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_restartServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 19:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_setTaskItemInfo_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(msg->response.context);

                        callback_setTaskItemInfo(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_setTaskItemInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_setTaskItemInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 20:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_shutdownNode_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 2, true);
                        setResponseContext(msg->response.context);

                        callback_shutdownNode(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_shutdownNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_shutdownNode_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 21:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_startServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(msg->response.context);

                        callback_startServer(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_startServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_startServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 22:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(msg->response.context);

                        callback_stopServer(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_stopServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 23:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_undeploy_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string log;
                        _is.read(log, 5, true);
                        setResponseContext(msg->response.context);

                        callback_undeploy(_ret, log);

                    }
                    catch(std::exception &ex)
                    {
                        callback_undeploy_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_undeploy_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 24:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_updatePatchLog_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(msg->response.context);

                        callback_updatePatchLog(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_updatePatchLog_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_updatePatchLog_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    protected:
        map<std::string, std::string> _mRspContext;
    };
    typedef tars::TC_AutoPtr<AdminRegCoroPrxCallback> AdminRegCoroPrxCallbackPtr;

    /* proxy for client */
    class AdminRegProxy : public tars::ServantProxy
    {
    public:
        typedef map<string, string> TARS_CONTEXT;
        tars::Int32 addTaskReq(const tars::TaskReq & taskReq,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(taskReq, 1);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"addTaskReq", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_addTaskReq(AdminRegPrxCallbackPtr callback,const tars::TaskReq &taskReq,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(taskReq, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"addTaskReq", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromiseaddTaskReqPtr > promise_async_addTaskReq(const tars::TaskReq &taskReq,const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromiseaddTaskReqPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(taskReq, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"addTaskReq", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_addTaskReq(AdminRegCoroPrxCallbackPtr callback,const tars::TaskReq &taskReq,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(taskReq, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"addTaskReq", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 batchPatch(const tars::PatchRequest & req,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            _os.write(result, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"batchPatch", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 2, true);
            return _ret;
        }

        void async_batchPatch(AdminRegPrxCallbackPtr callback,const tars::PatchRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"batchPatch", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromisebatchPatchPtr > promise_async_batchPatch(const tars::PatchRequest &req,const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromisebatchPatchPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"batchPatch", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_batchPatch(AdminRegCoroPrxCallbackPtr callback,const tars::PatchRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"batchPatch", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        vector<std::string> getAllApplicationNames(std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(result, 1);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"getAllApplicationNames", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            vector<std::string> _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 1, true);
            return _ret;
        }

        void async_getAllApplicationNames(AdminRegPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getAllApplicationNames", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromisegetAllApplicationNamesPtr > promise_async_getAllApplicationNames(const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromisegetAllApplicationNamesPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getAllApplicationNames", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getAllApplicationNames(AdminRegCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getAllApplicationNames", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        vector<std::string> getAllNodeNames(std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(result, 1);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"getAllNodeNames", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            vector<std::string> _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 1, true);
            return _ret;
        }

        void async_getAllNodeNames(AdminRegPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getAllNodeNames", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromisegetAllNodeNamesPtr > promise_async_getAllNodeNames(const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromisegetAllNodeNamesPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getAllNodeNames", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getAllNodeNames(AdminRegCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getAllNodeNames", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        vector<vector<std::string> > getAllServerIds(std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(result, 1);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"getAllServerIds", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            vector<vector<std::string> > _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 1, true);
            return _ret;
        }

        void async_getAllServerIds(AdminRegPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getAllServerIds", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromisegetAllServerIdsPtr > promise_async_getAllServerIds(const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromisegetAllServerIdsPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getAllServerIds", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getAllServerIds(AdminRegCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getAllServerIds", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 getClientIp(std::string &sClientIp,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(sClientIp, 1);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"getClientIp", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(sClientIp, 1, true);
            return _ret;
        }

        void async_getClientIp(AdminRegPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getClientIp", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromisegetClientIpPtr > promise_async_getClientIp(const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromisegetClientIpPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getClientIp", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getClientIp(AdminRegCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getClientIp", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 getGroupId(const std::string & ip,tars::Int32 &groupId,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(ip, 1);
            _os.write(groupId, 2);
            _os.write(result, 3);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"getGroupId", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(groupId, 2, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_getGroupId(AdminRegPrxCallbackPtr callback,const std::string &ip,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(ip, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getGroupId", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromisegetGroupIdPtr > promise_async_getGroupId(const std::string &ip,const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromisegetGroupIdPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(ip, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getGroupId", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getGroupId(AdminRegCoroPrxCallbackPtr callback,const std::string &ip,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(ip, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getGroupId", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 getNodeVesion(const std::string & name,std::string &version,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(name, 1);
            _os.write(version, 2);
            _os.write(result, 3);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"getNodeVesion", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(version, 2, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_getNodeVesion(AdminRegPrxCallbackPtr callback,const std::string &name,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getNodeVesion", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromisegetNodeVesionPtr > promise_async_getNodeVesion(const std::string &name,const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromisegetNodeVesionPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getNodeVesion", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getNodeVesion(AdminRegCoroPrxCallbackPtr callback,const std::string &name,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getNodeVesion", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 getPatchPercent(const std::string & application,const std::string & serverName,const std::string & nodeName,tars::PatchInfo &tPatchInfo,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(tPatchInfo, 4);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"getPatchPercent", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(tPatchInfo, 4, true);
            return _ret;
        }

        void async_getPatchPercent(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getPatchPercent", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromisegetPatchPercentPtr > promise_async_getPatchPercent(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromisegetPatchPercentPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getPatchPercent", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getPatchPercent(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getPatchPercent", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 getProfileTemplate(const std::string & profileName,std::string &profileTemplate,std::string &resultDesc,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(profileName, 1);
            _os.write(profileTemplate, 2);
            _os.write(resultDesc, 3);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"getProfileTemplate", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(profileTemplate, 2, true);
            _is.read(resultDesc, 3, true);
            return _ret;
        }

        void async_getProfileTemplate(AdminRegPrxCallbackPtr callback,const std::string &profileName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(profileName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getProfileTemplate", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromisegetProfileTemplatePtr > promise_async_getProfileTemplate(const std::string &profileName,const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromisegetProfileTemplatePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(profileName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getProfileTemplate", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getProfileTemplate(AdminRegCoroPrxCallbackPtr callback,const std::string &profileName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(profileName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getProfileTemplate", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 getServerProfileTemplate(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &profileTemplate,std::string &resultDesc,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(profileTemplate, 4);
            _os.write(resultDesc, 5);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"getServerProfileTemplate", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(profileTemplate, 4, true);
            _is.read(resultDesc, 5, true);
            return _ret;
        }

        void async_getServerProfileTemplate(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServerProfileTemplate", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromisegetServerProfileTemplatePtr > promise_async_getServerProfileTemplate(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromisegetServerProfileTemplatePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServerProfileTemplate", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getServerProfileTemplate(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServerProfileTemplate", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 getServerState(const std::string & application,const std::string & serverName,const std::string & nodeName,tars::ServerStateDesc &state,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(state, 4);
            _os.write(result, 5);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"getServerState", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(state, 4, true);
            _is.read(result, 5, true);
            return _ret;
        }

        void async_getServerState(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServerState", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromisegetServerStatePtr > promise_async_getServerState(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromisegetServerStatePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServerState", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getServerState(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServerState", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 getTaskHistory(const std::string & application,const std::string & serverName,const std::string & command,vector<tars::TaskRsp> &taskRsps,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            _os.write(taskRsps, 4);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"getTaskHistory", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(taskRsps, 4, true);
            return _ret;
        }

        void async_getTaskHistory(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &command,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getTaskHistory", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromisegetTaskHistoryPtr > promise_async_getTaskHistory(const std::string &application,const std::string &serverName,const std::string &command,const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromisegetTaskHistoryPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getTaskHistory", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getTaskHistory(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &command,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getTaskHistory", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 getTaskRsp(const std::string & taskNo,tars::TaskRsp &taskRsp,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(taskNo, 1);
            _os.write(taskRsp, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"getTaskRsp", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(taskRsp, 2, true);
            return _ret;
        }

        void async_getTaskRsp(AdminRegPrxCallbackPtr callback,const std::string &taskNo,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(taskNo, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getTaskRsp", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromisegetTaskRspPtr > promise_async_getTaskRsp(const std::string &taskNo,const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromisegetTaskRspPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(taskNo, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getTaskRsp", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getTaskRsp(AdminRegCoroPrxCallbackPtr callback,const std::string &taskNo,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(taskNo, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getTaskRsp", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 gridPatchServer(const vector<tars::ServerGridDesc> & gridDescList,vector<tars::ServerGridDesc> &gridFailDescList,std::string &resultDesc,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(gridDescList, 1);
            _os.write(gridFailDescList, 2);
            _os.write(resultDesc, 3);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"gridPatchServer", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(gridFailDescList, 2, true);
            _is.read(resultDesc, 3, true);
            return _ret;
        }

        void async_gridPatchServer(AdminRegPrxCallbackPtr callback,const vector<tars::ServerGridDesc> &gridDescList,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(gridDescList, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"gridPatchServer", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromisegridPatchServerPtr > promise_async_gridPatchServer(const vector<tars::ServerGridDesc> &gridDescList,const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromisegridPatchServerPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(gridDescList, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"gridPatchServer", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_gridPatchServer(AdminRegCoroPrxCallbackPtr callback,const vector<tars::ServerGridDesc> &gridDescList,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(gridDescList, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"gridPatchServer", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 loadServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(result, 4);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"loadServer", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_loadServer(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"loadServer", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromiseloadServerPtr > promise_async_loadServer(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromiseloadServerPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"loadServer", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_loadServer(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"loadServer", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 notifyServer(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & command,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(command, 4);
            _os.write(result, 5);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"notifyServer", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 5, true);
            return _ret;
        }

        void async_notifyServer(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &command,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(command, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"notifyServer", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromisenotifyServerPtr > promise_async_notifyServer(const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &command,const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromisenotifyServerPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(command, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"notifyServer", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_notifyServer(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &command,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(command, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"notifyServer", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Bool pingNode(const std::string & name,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(name, 1);
            _os.write(result, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"pingNode", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(result, 2, true);
            return _ret;
        }

        void async_pingNode(AdminRegPrxCallbackPtr callback,const std::string &name,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"pingNode", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromisepingNodePtr > promise_async_pingNode(const std::string &name,const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromisepingNodePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"pingNode", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_pingNode(AdminRegCoroPrxCallbackPtr callback,const std::string &name,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"pingNode", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 restartServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(result, 4);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"restartServer", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_restartServer(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"restartServer", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromiserestartServerPtr > promise_async_restartServer(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromiserestartServerPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"restartServer", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_restartServer(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"restartServer", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 setTaskItemInfo(const std::string & itemNo,const map<std::string, std::string> & info,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(itemNo, 1);
            _os.write(info, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"setTaskItemInfo", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_setTaskItemInfo(AdminRegPrxCallbackPtr callback,const std::string &itemNo,const map<std::string, std::string> &info,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(itemNo, 1);
            _os.write(info, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"setTaskItemInfo", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromisesetTaskItemInfoPtr > promise_async_setTaskItemInfo(const std::string &itemNo,const map<std::string, std::string> &info,const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromisesetTaskItemInfoPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(itemNo, 1);
            _os.write(info, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"setTaskItemInfo", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_setTaskItemInfo(AdminRegCoroPrxCallbackPtr callback,const std::string &itemNo,const map<std::string, std::string> &info,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(itemNo, 1);
            _os.write(info, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"setTaskItemInfo", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 shutdownNode(const std::string & name,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(name, 1);
            _os.write(result, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"shutdownNode", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 2, true);
            return _ret;
        }

        void async_shutdownNode(AdminRegPrxCallbackPtr callback,const std::string &name,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"shutdownNode", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromiseshutdownNodePtr > promise_async_shutdownNode(const std::string &name,const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromiseshutdownNodePtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"shutdownNode", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_shutdownNode(AdminRegCoroPrxCallbackPtr callback,const std::string &name,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(name, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"shutdownNode", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 startServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(result, 4);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"startServer", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_startServer(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"startServer", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromisestartServerPtr > promise_async_startServer(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromisestartServerPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"startServer", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_startServer(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"startServer", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 stopServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(result, 4);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"stopServer", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_stopServer(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopServer", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromisestopServerPtr > promise_async_stopServer(const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromisestopServerPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopServer", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_stopServer(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopServer", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 undeploy(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & user,std::string &log,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(user, 4);
            _os.write(log, 5);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"undeploy", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(log, 5, true);
            return _ret;
        }

        void async_undeploy(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &user,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(user, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"undeploy", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromiseundeployPtr > promise_async_undeploy(const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &user,const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromiseundeployPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(user, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"undeploy", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_undeploy(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &user,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(user, 4);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"undeploy", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 updatePatchLog(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & patchId,const std::string & user,const std::string & patchType,tars::Bool succ,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(patchId, 4);
            _os.write(user, 5);
            _os.write(patchType, 6);
            _os.write(succ, 7);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"updatePatchLog", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_updatePatchLog(AdminRegPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &patchId,const std::string &user,const std::string &patchType,tars::Bool succ,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(patchId, 4);
            _os.write(user, 5);
            _os.write(patchType, 6);
            _os.write(succ, 7);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"updatePatchLog", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< AdminRegPrxCallbackPromise::PromiseupdatePatchLogPtr > promise_async_updatePatchLog(const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &patchId,const std::string &user,const std::string &patchType,tars::Bool succ,const map<string, string>& context)
        {
            promise::Promise< AdminRegPrxCallbackPromise::PromiseupdatePatchLogPtr > promise;
            AdminRegPrxCallbackPromisePtr callback = new AdminRegPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(patchId, 4);
            _os.write(user, 5);
            _os.write(patchType, 6);
            _os.write(succ, 7);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"updatePatchLog", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_updatePatchLog(AdminRegCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &nodeName,const std::string &patchId,const std::string &user,const std::string &patchType,tars::Bool succ,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(nodeName, 3);
            _os.write(patchId, 4);
            _os.write(user, 5);
            _os.write(patchType, 6);
            _os.write(succ, 7);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"updatePatchLog", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        AdminRegProxy* tars_hash(int64_t key)
        {
            return (AdminRegProxy*)ServantProxy::tars_hash(key);
        }

        AdminRegProxy* tars_consistent_hash(int64_t key)
        {
            return (AdminRegProxy*)ServantProxy::tars_consistent_hash(key);
        }

        AdminRegProxy* tars_set_timeout(int msecond)
        {
            return (AdminRegProxy*)ServantProxy::tars_set_timeout(msecond);
        }

    };
    typedef tars::TC_AutoPtr<AdminRegProxy> AdminRegPrx;

    /* servant for server */
    class AdminReg : public tars::Servant
    {
    public:
        virtual ~AdminReg(){}
        virtual tars::Int32 addTaskReq(const tars::TaskReq & taskReq,tars::TarsCurrentPtr current) = 0;
        static void async_response_addTaskReq(tars::TarsCurrentPtr current, tars::Int32 _ret)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 batchPatch(const tars::PatchRequest & req,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_batchPatch(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual vector<std::string> getAllApplicationNames(std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_getAllApplicationNames(tars::TarsCurrentPtr current, const vector<std::string> &_ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual vector<std::string> getAllNodeNames(std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_getAllNodeNames(tars::TarsCurrentPtr current, const vector<std::string> &_ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual vector<vector<std::string> > getAllServerIds(std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_getAllServerIds(tars::TarsCurrentPtr current, const vector<vector<std::string> > &_ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 getClientIp(std::string &sClientIp,tars::TarsCurrentPtr current) = 0;
        static void async_response_getClientIp(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &sClientIp)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("sClientIp", sClientIp);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(sClientIp, 1);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 getGroupId(const std::string & ip,tars::Int32 &groupId,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_getGroupId(tars::TarsCurrentPtr current, tars::Int32 _ret, tars::Int32 groupId, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("groupId", groupId);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(groupId, 2);

                _os.write(result, 3);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 getNodeVesion(const std::string & name,std::string &version,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_getNodeVesion(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &version, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("version", version);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(version, 2);

                _os.write(result, 3);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 getPatchPercent(const std::string & application,const std::string & serverName,const std::string & nodeName,tars::PatchInfo &tPatchInfo,tars::TarsCurrentPtr current) = 0;
        static void async_response_getPatchPercent(tars::TarsCurrentPtr current, tars::Int32 _ret, const tars::PatchInfo &tPatchInfo)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("tPatchInfo", tPatchInfo);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(tPatchInfo, 4);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 getProfileTemplate(const std::string & profileName,std::string &profileTemplate,std::string &resultDesc,tars::TarsCurrentPtr current) = 0;
        static void async_response_getProfileTemplate(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &profileTemplate, const std::string &resultDesc)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("profileTemplate", profileTemplate);
                tarsAttr.put("resultDesc", resultDesc);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(profileTemplate, 2);

                _os.write(resultDesc, 3);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 getServerProfileTemplate(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &profileTemplate,std::string &resultDesc,tars::TarsCurrentPtr current) = 0;
        static void async_response_getServerProfileTemplate(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &profileTemplate, const std::string &resultDesc)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("profileTemplate", profileTemplate);
                tarsAttr.put("resultDesc", resultDesc);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(profileTemplate, 4);

                _os.write(resultDesc, 5);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 getServerState(const std::string & application,const std::string & serverName,const std::string & nodeName,tars::ServerStateDesc &state,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_getServerState(tars::TarsCurrentPtr current, tars::Int32 _ret, const tars::ServerStateDesc &state, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("state", state);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(state, 4);

                _os.write(result, 5);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 getTaskHistory(const std::string & application,const std::string & serverName,const std::string & command,vector<tars::TaskRsp> &taskRsps,tars::TarsCurrentPtr current) = 0;
        static void async_response_getTaskHistory(tars::TarsCurrentPtr current, tars::Int32 _ret, const vector<tars::TaskRsp> &taskRsps)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("taskRsps", taskRsps);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(taskRsps, 4);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 getTaskRsp(const std::string & taskNo,tars::TaskRsp &taskRsp,tars::TarsCurrentPtr current) = 0;
        static void async_response_getTaskRsp(tars::TarsCurrentPtr current, tars::Int32 _ret, const tars::TaskRsp &taskRsp)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("taskRsp", taskRsp);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(taskRsp, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 gridPatchServer(const vector<tars::ServerGridDesc> & gridDescList,vector<tars::ServerGridDesc> &gridFailDescList,std::string &resultDesc,tars::TarsCurrentPtr current) = 0;
        static void async_response_gridPatchServer(tars::TarsCurrentPtr current, tars::Int32 _ret, const vector<tars::ServerGridDesc> &gridFailDescList, const std::string &resultDesc)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("gridFailDescList", gridFailDescList);
                tarsAttr.put("resultDesc", resultDesc);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(gridFailDescList, 2);

                _os.write(resultDesc, 3);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 loadServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_loadServer(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 notifyServer(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & command,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_notifyServer(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 5);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Bool pingNode(const std::string & name,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_pingNode(tars::TarsCurrentPtr current, tars::Bool _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 restartServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_restartServer(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 setTaskItemInfo(const std::string & itemNo,const map<std::string, std::string> & info,tars::TarsCurrentPtr current) = 0;
        static void async_response_setTaskItemInfo(tars::TarsCurrentPtr current, tars::Int32 _ret)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 shutdownNode(const std::string & name,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_shutdownNode(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 startServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_startServer(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 stopServer(const std::string & application,const std::string & serverName,const std::string & nodeName,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_stopServer(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 undeploy(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & user,std::string &log,tars::TarsCurrentPtr current) = 0;
        static void async_response_undeploy(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &log)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("log", log);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(log, 5);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 updatePatchLog(const std::string & application,const std::string & serverName,const std::string & nodeName,const std::string & patchId,const std::string & user,const std::string & patchType,tars::Bool succ,tars::TarsCurrentPtr current) = 0;
        static void async_response_updatePatchLog(tars::TarsCurrentPtr current, tars::Int32 _ret)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

    public:
        int onDispatch(tars::TarsCurrentPtr _current, vector<char> &_sResponseBuffer)
        {
            static ::std::string __tars__AdminReg_all[]=
            {
                "addTaskReq",
                "batchPatch",
                "getAllApplicationNames",
                "getAllNodeNames",
                "getAllServerIds",
                "getClientIp",
                "getGroupId",
                "getNodeVesion",
                "getPatchPercent",
                "getProfileTemplate",
                "getServerProfileTemplate",
                "getServerState",
                "getTaskHistory",
                "getTaskRsp",
                "gridPatchServer",
                "loadServer",
                "notifyServer",
                "pingNode",
                "restartServer",
                "setTaskItemInfo",
                "shutdownNode",
                "startServer",
                "stopServer",
                "undeploy",
                "updatePatchLog"
            };

            pair<string*, string*> r = equal_range(__tars__AdminReg_all, __tars__AdminReg_all+25, _current->getFuncName());
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __tars__AdminReg_all)
            {
                case 0:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::TaskReq taskReq;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("taskReq", taskReq);
                    }
                    else
                    {
                        _is.read(taskReq, 1, true);
                    }
                    tars::Int32 _ret = addTaskReq(taskReq, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::PatchRequest req;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("req", req);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(req, 1, true);
                        _is.read(result, 2, false);
                    }
                    tars::Int32 _ret = batchPatch(req,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(result, 1, false);
                    }
                    vector<std::string> _ret = getAllApplicationNames(result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(result, 1, false);
                    }
                    vector<std::string> _ret = getAllNodeNames(result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(result, 1, false);
                    }
                    vector<vector<std::string> > _ret = getAllServerIds(result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string sClientIp;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.getByDefault("sClientIp", sClientIp, sClientIp);
                    }
                    else
                    {
                        _is.read(sClientIp, 1, false);
                    }
                    tars::Int32 _ret = getClientIp(sClientIp, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("sClientIp", sClientIp);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(sClientIp, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string ip;
                    tars::Int32 groupId;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("ip", ip);
                        tarsAttr.getByDefault("groupId", groupId, groupId);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(ip, 1, true);
                        _is.read(groupId, 2, false);
                        _is.read(result, 3, false);
                    }
                    tars::Int32 _ret = getGroupId(ip,groupId,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("groupId", groupId);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(groupId, 2);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string name;
                    std::string version;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("name", name);
                        tarsAttr.getByDefault("version", version, version);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(name, 1, true);
                        _is.read(version, 2, false);
                        _is.read(result, 3, false);
                    }
                    tars::Int32 _ret = getNodeVesion(name,version,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("version", version);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(version, 2);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    tars::PatchInfo tPatchInfo;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.get("nodeName", nodeName);
                        tarsAttr.getByDefault("tPatchInfo", tPatchInfo, tPatchInfo);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(tPatchInfo, 4, false);
                    }
                    tars::Int32 _ret = getPatchPercent(application,serverName,nodeName,tPatchInfo, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("tPatchInfo", tPatchInfo);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(tPatchInfo, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string profileName;
                    std::string profileTemplate;
                    std::string resultDesc;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("profileName", profileName);
                        tarsAttr.getByDefault("profileTemplate", profileTemplate, profileTemplate);
                        tarsAttr.getByDefault("resultDesc", resultDesc, resultDesc);
                    }
                    else
                    {
                        _is.read(profileName, 1, true);
                        _is.read(profileTemplate, 2, false);
                        _is.read(resultDesc, 3, false);
                    }
                    tars::Int32 _ret = getProfileTemplate(profileName,profileTemplate,resultDesc, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("profileTemplate", profileTemplate);
                            tarsAttr.put("resultDesc", resultDesc);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(profileTemplate, 2);
                            _os.write(resultDesc, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string profileTemplate;
                    std::string resultDesc;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.get("nodeName", nodeName);
                        tarsAttr.getByDefault("profileTemplate", profileTemplate, profileTemplate);
                        tarsAttr.getByDefault("resultDesc", resultDesc, resultDesc);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(profileTemplate, 4, false);
                        _is.read(resultDesc, 5, false);
                    }
                    tars::Int32 _ret = getServerProfileTemplate(application,serverName,nodeName,profileTemplate,resultDesc, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("profileTemplate", profileTemplate);
                            tarsAttr.put("resultDesc", resultDesc);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(profileTemplate, 4);
                            _os.write(resultDesc, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    tars::ServerStateDesc state;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.get("nodeName", nodeName);
                        tarsAttr.getByDefault("state", state, state);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(state, 4, false);
                        _is.read(result, 5, false);
                    }
                    tars::Int32 _ret = getServerState(application,serverName,nodeName,state,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("state", state);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(state, 4);
                            _os.write(result, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string command;
                    vector<tars::TaskRsp> taskRsps;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.get("command", command);
                        tarsAttr.getByDefault("taskRsps", taskRsps, taskRsps);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(command, 3, true);
                        _is.read(taskRsps, 4, false);
                    }
                    tars::Int32 _ret = getTaskHistory(application,serverName,command,taskRsps, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("taskRsps", taskRsps);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(taskRsps, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string taskNo;
                    tars::TaskRsp taskRsp;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("taskNo", taskNo);
                        tarsAttr.getByDefault("taskRsp", taskRsp, taskRsp);
                    }
                    else
                    {
                        _is.read(taskNo, 1, true);
                        _is.read(taskRsp, 2, false);
                    }
                    tars::Int32 _ret = getTaskRsp(taskNo,taskRsp, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("taskRsp", taskRsp);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(taskRsp, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    vector<tars::ServerGridDesc> gridDescList;
                    vector<tars::ServerGridDesc> gridFailDescList;
                    std::string resultDesc;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("gridDescList", gridDescList);
                        tarsAttr.getByDefault("gridFailDescList", gridFailDescList, gridFailDescList);
                        tarsAttr.getByDefault("resultDesc", resultDesc, resultDesc);
                    }
                    else
                    {
                        _is.read(gridDescList, 1, true);
                        _is.read(gridFailDescList, 2, false);
                        _is.read(resultDesc, 3, false);
                    }
                    tars::Int32 _ret = gridPatchServer(gridDescList,gridFailDescList,resultDesc, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("gridFailDescList", gridFailDescList);
                            tarsAttr.put("resultDesc", resultDesc);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(gridFailDescList, 2);
                            _os.write(resultDesc, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 15:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.get("nodeName", nodeName);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(result, 4, false);
                    }
                    tars::Int32 _ret = loadServer(application,serverName,nodeName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 16:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string command;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.get("nodeName", nodeName);
                        tarsAttr.get("command", command);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(command, 4, true);
                        _is.read(result, 5, false);
                    }
                    tars::Int32 _ret = notifyServer(application,serverName,nodeName,command,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 17:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string name;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("name", name);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(name, 1, true);
                        _is.read(result, 2, false);
                    }
                    tars::Bool _ret = pingNode(name,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 18:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.get("nodeName", nodeName);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(result, 4, false);
                    }
                    tars::Int32 _ret = restartServer(application,serverName,nodeName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 19:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string itemNo;
                    map<std::string, std::string> info;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("itemNo", itemNo);
                        tarsAttr.get("info", info);
                    }
                    else
                    {
                        _is.read(itemNo, 1, true);
                        _is.read(info, 2, true);
                    }
                    tars::Int32 _ret = setTaskItemInfo(itemNo,info, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 20:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string name;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("name", name);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(name, 1, true);
                        _is.read(result, 2, false);
                    }
                    tars::Int32 _ret = shutdownNode(name,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 21:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.get("nodeName", nodeName);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(result, 4, false);
                    }
                    tars::Int32 _ret = startServer(application,serverName,nodeName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 22:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.get("nodeName", nodeName);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(result, 4, false);
                    }
                    tars::Int32 _ret = stopServer(application,serverName,nodeName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 23:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string user;
                    std::string log;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.get("nodeName", nodeName);
                        tarsAttr.get("user", user);
                        tarsAttr.getByDefault("log", log, log);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(user, 4, true);
                        _is.read(log, 5, false);
                    }
                    tars::Int32 _ret = undeploy(application,serverName,nodeName,user,log, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("log", log);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(log, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 24:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string nodeName;
                    std::string patchId;
                    std::string user;
                    std::string patchType;
                    tars::Bool succ = false;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.get("nodeName", nodeName);
                        tarsAttr.get("patchId", patchId);
                        tarsAttr.get("user", user);
                        tarsAttr.get("patchType", patchType);
                        tarsAttr.get("succ", succ);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(nodeName, 3, true);
                        _is.read(patchId, 4, true);
                        _is.read(user, 5, true);
                        _is.read(patchType, 6, true);
                        _is.read(succ, 7, true);
                    }
                    tars::Int32 _ret = updatePatchLog(application,serverName,nodeName,patchId,user,patchType,succ, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }
    };


}



#endif
