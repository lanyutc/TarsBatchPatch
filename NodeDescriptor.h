// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.1.0.
// **********************************************************************

#ifndef __NODEDESCRIPTOR_H_
#define __NODEDESCRIPTOR_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
using namespace std;


namespace tars
{
    enum ServerState
    {
        Inactive,
        Activating,
        Active,
        Deactivating,
        Destroying,
        Destroyed,
    };
    inline string etos(const ServerState & e)
    {
        switch(e)
        {
            case Inactive: return "Inactive";
            case Activating: return "Activating";
            case Active: return "Active";
            case Deactivating: return "Deactivating";
            case Destroying: return "Destroying";
            case Destroyed: return "Destroyed";
            default: return "";
        }
    }
    inline int stoe(const string & s, ServerState & e)
    {
        if(s == "Inactive")  { e=Inactive; return 0;}
        if(s == "Activating")  { e=Activating; return 0;}
        if(s == "Active")  { e=Active; return 0;}
        if(s == "Deactivating")  { e=Deactivating; return 0;}
        if(s == "Destroying")  { e=Destroying; return 0;}
        if(s == "Destroyed")  { e=Destroyed; return 0;}

        return -1;
    }

    struct LoadInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.LoadInfo";
        }
        static string MD5()
        {
            return "51ba7d6564ede253c29d5a3399944a1b";
        }
        LoadInfo()
        :avg1(0),avg5(0),avg15(0),avgCpu(0)
        {
        }
        void resetDefautlt()
        {
            avg1 = 0;
            avg5 = 0;
            avg15 = 0;
            avgCpu = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(avg1, 0);
            _os.write(avg5, 1);
            _os.write(avg15, 2);
            if (avgCpu != 0)
            {
                _os.write(avgCpu, 3);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(avg1, 0, true);
            _is.read(avg5, 1, true);
            _is.read(avg15, 2, true);
            _is.read(avgCpu, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(avg1,"avg1");
            _ds.display(avg5,"avg5");
            _ds.display(avg15,"avg15");
            _ds.display(avgCpu,"avgCpu");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(avg1, true);
            _ds.displaySimple(avg5, true);
            _ds.displaySimple(avg15, true);
            _ds.displaySimple(avgCpu, false);
            return _os;
        }
    public:
        tars::Float avg1;
        tars::Float avg5;
        tars::Float avg15;
        tars::Int32 avgCpu;
    };
    inline bool operator==(const LoadInfo&l, const LoadInfo&r)
    {
        return l.avg1 == r.avg1 && l.avg5 == r.avg5 && l.avg15 == r.avg15 && l.avgCpu == r.avgCpu;
    }
    inline bool operator!=(const LoadInfo&l, const LoadInfo&r)
    {
        return !(l == r);
    }

    struct PatchInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.PatchInfo";
        }
        static string MD5()
        {
            return "8c67e0afd48e8af5b3238a284ca8ac20";
        }
        PatchInfo()
        :bPatching(false),iPercent(0),iModifyTime(0),sVersion(""),sResult(""),bSucc(false)
        {
        }
        void resetDefautlt()
        {
            bPatching = false;
            iPercent = 0;
            iModifyTime = 0;
            sVersion = "";
            sResult = "";
            bSucc = false;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(bPatching, 0);
            _os.write(iPercent, 1);
            _os.write(iModifyTime, 2);
            _os.write(sVersion, 3);
            _os.write(sResult, 4);
            if (bSucc != false)
            {
                _os.write(bSucc, 5);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(bPatching, 0, true);
            _is.read(iPercent, 1, true);
            _is.read(iModifyTime, 2, true);
            _is.read(sVersion, 3, true);
            _is.read(sResult, 4, true);
            _is.read(bSucc, 5, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(bPatching,"bPatching");
            _ds.display(iPercent,"iPercent");
            _ds.display(iModifyTime,"iModifyTime");
            _ds.display(sVersion,"sVersion");
            _ds.display(sResult,"sResult");
            _ds.display(bSucc,"bSucc");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(bPatching, true);
            _ds.displaySimple(iPercent, true);
            _ds.displaySimple(iModifyTime, true);
            _ds.displaySimple(sVersion, true);
            _ds.displaySimple(sResult, true);
            _ds.displaySimple(bSucc, false);
            return _os;
        }
    public:
        tars::Bool bPatching;
        tars::Int32 iPercent;
        tars::Int32 iModifyTime;
        std::string sVersion;
        std::string sResult;
        tars::Bool bSucc;
    };
    inline bool operator==(const PatchInfo&l, const PatchInfo&r)
    {
        return l.bPatching == r.bPatching && l.iPercent == r.iPercent && l.iModifyTime == r.iModifyTime && l.sVersion == r.sVersion && l.sResult == r.sResult && l.bSucc == r.bSucc;
    }
    inline bool operator!=(const PatchInfo&l, const PatchInfo&r)
    {
        return !(l == r);
    }

    struct PreparePatchInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.PreparePatchInfo";
        }
        static string MD5()
        {
            return "716a45598331cd036c23128ce51ae6ff";
        }
        PreparePatchInfo()
        :bPreparePatching(false),iPercent(0),iModifyTime(0),sVersion(""),sResult(""),ret(0)
        {
        }
        void resetDefautlt()
        {
            bPreparePatching = false;
            iPercent = 0;
            iModifyTime = 0;
            sVersion = "";
            sResult = "";
            ret = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(bPreparePatching, 0);
            _os.write(iPercent, 1);
            _os.write(iModifyTime, 2);
            _os.write(sVersion, 3);
            _os.write(sResult, 4);
            if (ret != 0)
            {
                _os.write(ret, 5);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(bPreparePatching, 0, true);
            _is.read(iPercent, 1, true);
            _is.read(iModifyTime, 2, true);
            _is.read(sVersion, 3, true);
            _is.read(sResult, 4, true);
            _is.read(ret, 5, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(bPreparePatching,"bPreparePatching");
            _ds.display(iPercent,"iPercent");
            _ds.display(iModifyTime,"iModifyTime");
            _ds.display(sVersion,"sVersion");
            _ds.display(sResult,"sResult");
            _ds.display(ret,"ret");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(bPreparePatching, true);
            _ds.displaySimple(iPercent, true);
            _ds.displaySimple(iModifyTime, true);
            _ds.displaySimple(sVersion, true);
            _ds.displaySimple(sResult, true);
            _ds.displaySimple(ret, false);
            return _os;
        }
    public:
        tars::Bool bPreparePatching;
        tars::Int32 iPercent;
        tars::Int32 iModifyTime;
        std::string sVersion;
        std::string sResult;
        tars::Int32 ret;
    };
    inline bool operator==(const PreparePatchInfo&l, const PreparePatchInfo&r)
    {
        return l.bPreparePatching == r.bPreparePatching && l.iPercent == r.iPercent && l.iModifyTime == r.iModifyTime && l.sVersion == r.sVersion && l.sResult == r.sResult && l.ret == r.ret;
    }
    inline bool operator!=(const PreparePatchInfo&l, const PreparePatchInfo&r)
    {
        return !(l == r);
    }

    struct NodeInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.NodeInfo";
        }
        static string MD5()
        {
            return "d895b45269767bd90118ccd8955db52c";
        }
        NodeInfo()
        :nodeName(""),nodeObj(""),endpointIp(""),endpointPort(0),timeOut(0),dataDir(""),version(""),coreFileSize(""),openFiles(0)
        {
        }
        void resetDefautlt()
        {
            nodeName = "";
            nodeObj = "";
            endpointIp = "";
            endpointPort = 0;
            timeOut = 0;
            dataDir = "";
            version = "";
            coreFileSize = "";
            openFiles = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(nodeName, 0);
            _os.write(nodeObj, 1);
            _os.write(endpointIp, 2);
            _os.write(endpointPort, 3);
            _os.write(timeOut, 4);
            _os.write(dataDir, 5);
            if (version != "")
            {
                _os.write(version, 6);
            }
            if (coreFileSize != "")
            {
                _os.write(coreFileSize, 7);
            }
            if (openFiles != 0)
            {
                _os.write(openFiles, 8);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(nodeName, 0, true);
            _is.read(nodeObj, 1, true);
            _is.read(endpointIp, 2, true);
            _is.read(endpointPort, 3, true);
            _is.read(timeOut, 4, true);
            _is.read(dataDir, 5, true);
            _is.read(version, 6, false);
            _is.read(coreFileSize, 7, false);
            _is.read(openFiles, 8, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(nodeName,"nodeName");
            _ds.display(nodeObj,"nodeObj");
            _ds.display(endpointIp,"endpointIp");
            _ds.display(endpointPort,"endpointPort");
            _ds.display(timeOut,"timeOut");
            _ds.display(dataDir,"dataDir");
            _ds.display(version,"version");
            _ds.display(coreFileSize,"coreFileSize");
            _ds.display(openFiles,"openFiles");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(nodeName, true);
            _ds.displaySimple(nodeObj, true);
            _ds.displaySimple(endpointIp, true);
            _ds.displaySimple(endpointPort, true);
            _ds.displaySimple(timeOut, true);
            _ds.displaySimple(dataDir, true);
            _ds.displaySimple(version, true);
            _ds.displaySimple(coreFileSize, true);
            _ds.displaySimple(openFiles, false);
            return _os;
        }
    public:
        std::string nodeName;
        std::string nodeObj;
        std::string endpointIp;
        tars::Int32 endpointPort;
        tars::Short timeOut;
        std::string dataDir;
        std::string version;
        std::string coreFileSize;
        tars::Int32 openFiles;
    };
    inline bool operator==(const NodeInfo&l, const NodeInfo&r)
    {
        return l.nodeName == r.nodeName && l.nodeObj == r.nodeObj && l.endpointIp == r.endpointIp && l.endpointPort == r.endpointPort && l.timeOut == r.timeOut && l.dataDir == r.dataDir && l.version == r.version && l.coreFileSize == r.coreFileSize && l.openFiles == r.openFiles;
    }
    inline bool operator!=(const NodeInfo&l, const NodeInfo&r)
    {
        return !(l == r);
    }

    struct ServerStateInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.ServerStateInfo";
        }
        static string MD5()
        {
            return "c40a2543579a02b90cb67de80a617a38";
        }
        ServerStateInfo()
        :serverState(tars::Inactive),processId(0),nodeName(""),application(""),serverName(""),settingState(tars::Inactive)
        {
        }
        void resetDefautlt()
        {
            processId = 0;
            nodeName = "";
            application = "";
            serverName = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write((tars::Int32)serverState, 0);
            _os.write(processId, 1);
            if (nodeName != "")
            {
                _os.write(nodeName, 2);
            }
            if (application != "")
            {
                _os.write(application, 3);
            }
            if (serverName != "")
            {
                _os.write(serverName, 4);
            }
            _os.write((tars::Int32)settingState, 5);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            tars::Int32 eTemp0 = tars::Inactive;
            _is.read(eTemp0, 0, true);
            serverState = (tars::ServerState)eTemp0;
            _is.read(processId, 1, true);
            _is.read(nodeName, 2, false);
            _is.read(application, 3, false);
            _is.read(serverName, 4, false);
            tars::Int32 eTemp5 = tars::Inactive;
            _is.read(eTemp5, 5, false);
            settingState = (tars::ServerState)eTemp5;
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display((tars::Int32)serverState,"serverState");
            _ds.display(processId,"processId");
            _ds.display(nodeName,"nodeName");
            _ds.display(application,"application");
            _ds.display(serverName,"serverName");
            _ds.display((tars::Int32)settingState,"settingState");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple((tars::Int32)serverState, true);
            _ds.displaySimple(processId, true);
            _ds.displaySimple(nodeName, true);
            _ds.displaySimple(application, true);
            _ds.displaySimple(serverName, true);
            _ds.displaySimple((tars::Int32)settingState, false);
            return _os;
        }
    public:
        tars::ServerState serverState;
        tars::Int32 processId;
        std::string nodeName;
        std::string application;
        std::string serverName;
        tars::ServerState settingState;
    };
    inline bool operator==(const ServerStateInfo&l, const ServerStateInfo&r)
    {
        return l.serverState == r.serverState && l.processId == r.processId && l.nodeName == r.nodeName && l.application == r.application && l.serverName == r.serverName && l.settingState == r.settingState;
    }
    inline bool operator!=(const ServerStateInfo&l, const ServerStateInfo&r)
    {
        return !(l == r);
    }

    struct PatchRequest : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.PatchRequest";
        }
        static string MD5()
        {
            return "b1b7c1f4565fe3a2a3749c726451a6f9";
        }
        PatchRequest()
        :appname(""),servername(""),nodename(""),groupname(""),binname(""),version(""),user(""),servertype(""),patchobj(""),md5(""),ostype(""),filepath("")
        {
        }
        void resetDefautlt()
        {
            appname = "";
            servername = "";
            nodename = "";
            groupname = "";
            binname = "";
            version = "";
            user = "";
            servertype = "";
            patchobj = "";
            md5 = "";
            ostype = "";
            filepath = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(appname, 0);
            _os.write(servername, 1);
            _os.write(nodename, 2);
            _os.write(groupname, 3);
            _os.write(binname, 4);
            _os.write(version, 5);
            _os.write(user, 6);
            _os.write(servertype, 7);
            _os.write(patchobj, 8);
            _os.write(md5, 9);
            if (ostype != "")
            {
                _os.write(ostype, 10);
            }
            if (filepath != "")
            {
                _os.write(filepath, 11);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(appname, 0, true);
            _is.read(servername, 1, true);
            _is.read(nodename, 2, true);
            _is.read(groupname, 3, true);
            _is.read(binname, 4, true);
            _is.read(version, 5, true);
            _is.read(user, 6, true);
            _is.read(servertype, 7, true);
            _is.read(patchobj, 8, true);
            _is.read(md5, 9, true);
            _is.read(ostype, 10, false);
            _is.read(filepath, 11, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(appname,"appname");
            _ds.display(servername,"servername");
            _ds.display(nodename,"nodename");
            _ds.display(groupname,"groupname");
            _ds.display(binname,"binname");
            _ds.display(version,"version");
            _ds.display(user,"user");
            _ds.display(servertype,"servertype");
            _ds.display(patchobj,"patchobj");
            _ds.display(md5,"md5");
            _ds.display(ostype,"ostype");
            _ds.display(filepath,"filepath");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(appname, true);
            _ds.displaySimple(servername, true);
            _ds.displaySimple(nodename, true);
            _ds.displaySimple(groupname, true);
            _ds.displaySimple(binname, true);
            _ds.displaySimple(version, true);
            _ds.displaySimple(user, true);
            _ds.displaySimple(servertype, true);
            _ds.displaySimple(patchobj, true);
            _ds.displaySimple(md5, true);
            _ds.displaySimple(ostype, true);
            _ds.displaySimple(filepath, false);
            return _os;
        }
    public:
        std::string appname;
        std::string servername;
        std::string nodename;
        std::string groupname;
        std::string binname;
        std::string version;
        std::string user;
        std::string servertype;
        std::string patchobj;
        std::string md5;
        std::string ostype;
        std::string filepath;
    };
    inline bool operator==(const PatchRequest&l, const PatchRequest&r)
    {
        return l.appname == r.appname && l.servername == r.servername && l.nodename == r.nodename && l.groupname == r.groupname && l.binname == r.binname && l.version == r.version && l.user == r.user && l.servertype == r.servertype && l.patchobj == r.patchobj && l.md5 == r.md5 && l.ostype == r.ostype && l.filepath == r.filepath;
    }
    inline bool operator!=(const PatchRequest&l, const PatchRequest&r)
    {
        return !(l == r);
    }

    struct PreparePatchRequest : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.PreparePatchRequest";
        }
        static string MD5()
        {
            return "fe70f8db87044a1fecbaa5f4822c8734";
        }
        PreparePatchRequest()
        :appname(""),servername(""),groupname(""),version(""),user(""),servertype(""),patchobj(""),md5(""),ostype(""),filepath("")
        {
        }
        void resetDefautlt()
        {
            appname = "";
            servername = "";
            groupname = "";
            version = "";
            user = "";
            servertype = "";
            patchobj = "";
            md5 = "";
            ostype = "";
            filepath = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(appname, 0);
            _os.write(servername, 1);
            _os.write(groupname, 2);
            _os.write(version, 3);
            _os.write(user, 4);
            _os.write(servertype, 5);
            _os.write(patchobj, 6);
            _os.write(md5, 7);
            _os.write(ostype, 8);
            _os.write(specialNodeList, 9);
            if (filepath != "")
            {
                _os.write(filepath, 10);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(appname, 0, true);
            _is.read(servername, 1, true);
            _is.read(groupname, 2, true);
            _is.read(version, 3, true);
            _is.read(user, 4, true);
            _is.read(servertype, 5, true);
            _is.read(patchobj, 6, true);
            _is.read(md5, 7, true);
            _is.read(ostype, 8, true);
            _is.read(specialNodeList, 9, true);
            _is.read(filepath, 10, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(appname,"appname");
            _ds.display(servername,"servername");
            _ds.display(groupname,"groupname");
            _ds.display(version,"version");
            _ds.display(user,"user");
            _ds.display(servertype,"servertype");
            _ds.display(patchobj,"patchobj");
            _ds.display(md5,"md5");
            _ds.display(ostype,"ostype");
            _ds.display(specialNodeList,"specialNodeList");
            _ds.display(filepath,"filepath");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(appname, true);
            _ds.displaySimple(servername, true);
            _ds.displaySimple(groupname, true);
            _ds.displaySimple(version, true);
            _ds.displaySimple(user, true);
            _ds.displaySimple(servertype, true);
            _ds.displaySimple(patchobj, true);
            _ds.displaySimple(md5, true);
            _ds.displaySimple(ostype, true);
            _ds.displaySimple(specialNodeList, true);
            _ds.displaySimple(filepath, false);
            return _os;
        }
    public:
        std::string appname;
        std::string servername;
        std::string groupname;
        std::string version;
        std::string user;
        std::string servertype;
        std::string patchobj;
        std::string md5;
        std::string ostype;
        vector<std::string> specialNodeList;
        std::string filepath;
    };
    inline bool operator==(const PreparePatchRequest&l, const PreparePatchRequest&r)
    {
        return l.appname == r.appname && l.servername == r.servername && l.groupname == r.groupname && l.version == r.version && l.user == r.user && l.servertype == r.servertype && l.patchobj == r.patchobj && l.md5 == r.md5 && l.ostype == r.ostype && l.specialNodeList == r.specialNodeList && l.filepath == r.filepath;
    }
    inline bool operator!=(const PreparePatchRequest&l, const PreparePatchRequest&r)
    {
        return !(l == r);
    }
    inline bool operator<(const PreparePatchRequest&l, const PreparePatchRequest&r)
    {
        if(l.appname != r.appname)  return (l.appname < r.appname);
        if(l.servername != r.servername)  return (l.servername < r.servername);
        if(l.version != r.version)  return (l.version < r.version);
        return false;
    }
    inline bool operator<=(const PreparePatchRequest&l, const PreparePatchRequest&r)
    {
        return !(r < l);
    }
    inline bool operator>(const PreparePatchRequest&l, const PreparePatchRequest&r)
    {
        return r < l;
    }
    inline bool operator>=(const PreparePatchRequest&l, const PreparePatchRequest&r)
    {
        return !(l < r);
    }


}



#endif
